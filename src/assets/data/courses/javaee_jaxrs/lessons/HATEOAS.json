{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we'll learn about an important concept relating to REST APIs: HATEOAS\n","permalinkName":"HATEOAS","title":"HATEOAS","unitSlNo":"1.12","youtube":"NK3HNEwDXUk","duration":854,"slNo":12,"prev":"/courses/javaee_jaxrs/Rest-Response","next":"/courses/javaee_jaxrs/The-Richardson-Maturity-Model","content":"<p>That&#39;s not a typo. This is actually an acronym. HATEOAS. In the running for the worst acronym ever. It stands for Hypermedia as the Engine of Application State. I know. Worst acronym ever, huh? But bear with me, and you&#39;ll soon understand what that means.</p>\n<h2 id=\"hyperlinking\">Hyperlinking</h2>\n<p>Maybe you remember, I mentioned in the first video of this series that there&#39;s no service definition specification for REST APIs. There&#39;s no formal document that really documents the API. Most REST APIs have &quot;help&quot; pages that explain what the API URIs are and what operations are supported. I also mentioned in the first video that the best RESTful APIs don&#39;t even need any documentation. I&#39;ll now explain what I mean by that.</p>\n<p>So, we visit websites online all the time. When was the last time you looked up any documentation to use a website? Well, never, I hope. You don&#39;t need documentation to use web sites. You go to the home page, and you&#39;ll find links to other pages. You click on one such link, and you&#39;ll get that page, with more links. You don&#39;t need to read a document to know where to go. You just remember the website home address, and any other links you need to navigate will be provided to you in the response.</p>\n<p>This is basically the advantage of using HTTP. Remember that HTTP is HyperText Transfer Protocol. We&#39;ve discussed that hypertext is text that has links to other text. These links, which are called hyperlinks, are what&#39;s really handy to navigate your way through any site. Let&#39;s think about the response we return in our REST API. What if we implement the same concept there too? Let&#39;s say you receive a GET request from a client for a message ID. We return the message information in JSON or XML, yes. But what you could also do is send links to comment resource URIs. And likes and shares resource URIs. It&#39;s the server saying &quot;Hey client, I know you asked for message ID 20. Here&#39;s the contents of message #20. I&#39;m also throwing in collection resource URIs for comments, shares and likes. If you want to get a list of all the comments for message ID 20, this is the URI to use. Oh, and here&#39;s the profile resource URI for the author of the message, if you want to get the profile information of the author of this message&quot;. </p>\n<p>So, the web service is being super-helpful to the client by providing all these links in the response. Similar to hyperlinks in web sites. Whether the client wants to use it or not doesn&#39;t matter. But if they want it, it&#39;s there. And just like that, you&#39;ve eliminated the need for documentation for all these APIs. The client developer just picks up the value of the right URIs from a previous response and makes subsequent calls to those URIs. </p>\n<p>If you do this, you don&#39;t let the client programmer have to know and hard-code the URIs in order to interact with the resources and the application state. You basically let the hypertext you send in the response drive the client&#39;s interaction with the application state. So, you could say that hypertext, or hypermedia as it is sometimes called, is being the driver or engine of application state. Hypermedia as the Engine of Application State. HATEOAS. Whew. Does that make sense now? It&#39;s still a bad choice for a name. But it should at least make some sense now.</p>\n<h2 id=\"a-scenario\">A Scenario</h2>\n<p>Let&#39;s walk through a scenario so that this concept becomes clearer. Let&#39;s start with the <code>/messages</code> collection URI. Accessing <code>/messages</code> should give you a list of messages in the system. Let&#39;s say a message representation has the following fields:</p>\n<ol>\n<li>Message ID</li>\n<li>Message Content</li>\n<li>Message Author</li>\n<li>Posted Date</li>\n</ol>\n<p>Four simple properties. A JSON representation for a sample message would look something like this:</p>\n<pre><code>{\n  &quot;id&quot;: &quot;01&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;\n}\n</code></pre><p>Now when you access the <code>/messages</code> collection URI, you&#39;d basically get a collection of such message resources. To keep it simple, let&#39;s say there are just 3 messages in the system. Accessing <code>/messages</code> would give something similar to this:</p>\n<pre><code>[\n  {\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;\n  },\n  {\n  &quot;id&quot;: &quot;2&quot;,\n  &quot;content&quot;: &quot;Yo!&quot;,\n  &quot;author&quot;: &quot;sid&quot;,\n  &quot;postedDate&quot;: &quot;04-01-2014&quot;\n  },\n  {\n  &quot;id&quot;: &quot;3&quot;,\n  &quot;content&quot;: &quot;What&#39;s up?&quot;,\n  &quot;author&quot;: &quot;jane&quot;,\n  &quot;postedDate&quot;: &quot;04-02-2014&quot;\n  }\n]\n</code></pre><p>Now that the client has the list of messages, let&#39;s say they want the details of the first message - message ID 1. We&#39;ve already designed the resource URI for message to be <code>/messages/{messageId}</code>. So, to get the URI, they&#39;ll have to take the value of the ID field of the message they are interested in, and append it to the string <code>/messages/</code> and there they have the resource URI. But this means that the client will have to know this beforehand. They need to know that they need to pick up the ID property from the response, and they need to know what to append it to. Now, here&#39;s a question. As a API service implementer, why not send that to the client yourself? Since we are sending the message resource details anyway, why not just construct the URI fully and send it to the client? </p>\n<p>Consider a sample response for a single message like this:</p>\n<pre><code>{\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;,\n  &quot;href&quot;: &quot;/messages/1&quot;\n}\n</code></pre><p>If this were to be the kind of response for every message in <code>/messages</code>, then the client wouldn&#39;t really have to do any URI construction. The resource URI is one of the properties of the resource. If you were to design your API so that every resource has the instance resource URI to itself, it makes it really convenient for the client to use it.</p>\n<p>Notice that the name of the link property is <code>href</code>. That must be familiar. That&#39;s exactly how you specify links in HTML. <code>href</code> is a property of the <code>&lt;a&gt;</code> tag. It serves a similar purpose here.</p>\n<h2 id=\"link-relations\">Link relations</h2>\n<p>We are on our way to implementing some HATEOAS concepts. We are not fully there yet. There are still some more things you&#39;ll need to learn. Let&#39;s look at the concept of links, and how you can apply them to the resources in the Messenger API. We&#39;ve looked at adding the resource URI to every resource. So, a profile resource, or a comment resource, well, pretty much every resource could have a <code>href</code> attribute that has the value of the instance resource URI. Bu that&#39;s not the only link you can provide. For instance, a message resource could also have links to get all the comments for that message. And all the likes and shares for that message. You could even have links for the client to post a new comment to that message. Keep extending this, and it gets a bit messy.</p>\n<pre><code>{\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;,\n  &quot;href&quot;: &quot;/messages/1&quot;,\n  &quot;comments-href&quot;: &quot;/messages/1/comments&quot;,\n  &quot;likes-href&quot;: &quot;/messages/1/likes&quot;,\n   &quot;shares-href&quot;: &quot;/messages/1/shares&quot;,\n   &quot;profile-href&quot;: &quot;/profiles/koushik&quot;,\n   &quot;comment-post-href&quot;: &quot;/messages/1/comments&quot;\n}\n</code></pre><p>If you do this, the client doesn&#39;t need to remember the URIs, yes, but they now have to remember the property names for these URIs and you basically have then same problem. There needs to be a better way to manage these links. And there is! You can use the <code>rel</code> attribute. </p>\n<p>If you&#39;ve used the anchor tags when writing HTML, you might have encountered this <code>rel</code> attribute before. It&#39;s basically an attribute that you can add to any link to specify the relationship between the current document and  the linked document. </p>\n<p>The most common example of <code>rel</code> is in stylesheet links. You&#39;d have seen stylesheet links in HTML head tags like this:</p>\n<p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/some.css&quot;/&gt;</code></p>\n<p>Here <code>href</code> provides the actual URL being linked, and the <code>rel</code> attribute describes the relation of that link to the main document. Here the relation is that the link is a stylesheet of the main document.</p>\n<p>We can use the <code>rel</code> attribute to add extra information in the links in our REST response. Here&#39;s the original href response modified with the <code>rel</code> attribute addition:</p>\n<pre><code>{\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;,\n   &quot;links&quot; : [\n                {  \n                    &quot;href&quot;: &quot;/messages/1&quot;,\n                    &quot;rel&quot;: &quot;self&quot;\n                }\n            ]\n}\n</code></pre><p>What&#39;s different here is that we&#39;ve introduced this new property called <code>links</code> which is an array. This is going to contain all the links that you&#39;d want to embed in the response. However, you add the <code>rel</code> attribute to make it clear what the link points to. Notice the <code>rel</code> value <code>self</code> which indicates that the link in the resource points to itself.</p>\n<p>This could be extended by adding new links and assigning the appropriate rel values for each:</p>\n<pre><code>{\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;,\n   &quot;links&quot; : [\n                {  \n                    &quot;href&quot;: &quot;/messages/1&quot;,\n                    &quot;rel&quot;: &quot;self&quot;\n                },\n                {  \n                    &quot;href&quot;: &quot;/messages/1/comments&quot;,\n                    &quot;rel&quot;: &quot;comments&quot;\n                },\n                {  \n                    &quot;href&quot;: &quot;/messages/1/likes&quot;,\n                    &quot;rel&quot;: &quot;likes&quot;\n                },\n                {  \n                    &quot;href&quot;: &quot;/messages/1/shares&quot;,\n                    &quot;rel&quot;: &quot;shares&quot;\n                },\n                {  \n                    &quot;href&quot;: &quot;/profiles/koushik&quot;,\n                    &quot;rel&quot;: &quot;author&quot;\n                }\n            ]\n}\n</code></pre><p>Now the client doesn&#39;t need to remember the link property values. They just have to find the link with the right <code>rel</code> value for the resource they want and then look up the <code>href</code> value from that link.</p>\n<p>A couple of things to note here. While the concept of having the URIs in the response to achieve HATEOAS is something that&#39;s well understood and mostly agreed upon by all, the <em>way</em> to do this could vary differently among implementations. The format of JSON that I&#39;ve outlined here is just one of the multitude of ways you could structure links. Again, there&#39;s no right or wrong. You can choose to tweak how you want to present the links in the JSON response of your API depending on your preference. Secondly, the <code>rel</code> attribute is a part of the HTTP specification, so there are only certain standard values that are allowed for it. <a href=\"http://www.iana.org/assignments/link-relations/link-relations.xml\">This link</a> lists the available values. And obviously, the <code>rel</code> values here like &quot;comments&quot; and &quot;likes&quot; are not valid. But we&#39;ll still use it. Like I mentioned before, the idea is to have an API that&#39;s easy for the clients to use, and easy for you to maintain. You don&#39;t want to focus too much on getting things right and going by the book. At least, not at the cost of complicating the API too much.</p>\n<p>In summary, HATEOAS is a way to provide links to resources in the API response, so that the client doesn&#39;t have to deal with URI construction and business flow. They make a request, and the next steps, along with the URIs are handed to them in the response. When you write APIs, you can choose to add URIs in the response using the <code>href</code> attribute. You can also provide more information about the relationship of the linked resource using the <code>rel</code> attribute.</p>\n","type":"video","durationText":"14 minutes","topic":"javaee","unit":{"lessons":[{"title":"Introduction","description":"Welcome to this course. This tutorial introduces you to REST APIs and explains some basic concepts.","permalinkName":"Introduction","type":"video","slNo":1,"durationText":"16 minutes"},{"title":"REST and HTTP","description":"In this tutorial, we will learn some HTTP concepts that have influenced REST.","permalinkName":"REST-and-HTTP","type":"video","slNo":2,"durationText":"14 minutes"},{"title":"HTTP Concepts","description":"In this tutorial, we will learn some HTTP concepts that have influenced REST.","permalinkName":"HTTP-Concepts","type":"quiz","slNo":3,"durationText":"5 questions"},{"title":"Designing Resource URIs","description":"In this tutorial, we’ll start designing a sample RESTful API for our sample social media application. And through the process, we’ll understand how RESTful URIs are designed.","permalinkName":"Designing-Resource-URIs","type":"video","slNo":4,"durationText":"18 minutes"},{"title":"Resource URIs","description":"In this tutorial, we’ll start designing a sample RESTful API for our sample social media application. And through the process, we’ll understand how RESTful URIs are designed.","permalinkName":"Resource-URIs","type":"quiz","slNo":5,"durationText":"3 questions"},{"title":"RESTful URI types","description":"You can think of RESTful URIs as belonging to two types: instance resource URIs and collection resource URIs. Let's understand what they mean.","permalinkName":"RESTful-URI-types","type":"video","slNo":6,"durationText":"7 minutes"},{"title":"URI types","description":"You can think of RESTful URIs as belonging to two types: instance resource URIs and collection resource URIs. Let's understand what they mean.","permalinkName":"URI-types","type":"quiz","slNo":7,"durationText":"4 questions"},{"title":"HTTP Methods","description":"Now that we've identified some important resource URIs, let's work on the operations that can be performed and the data that's exchanged.","permalinkName":"HTTP-Methods","type":"video","slNo":8,"durationText":"11 minutes"},{"title":"HTTP Methods","description":"Now that we've identified some important resource URIs, let's work on the operations that can be performed and the data that's exchanged.","permalinkName":"HTTP-Methods","type":"quiz","slNo":9,"durationText":"3 questions"},{"title":"Idempotence In HTTP Methods","description":"Idempotence. Yes, that's a word. And it's an important property of HTTP methods according to the specifications.","permalinkName":"Idempotence-In-HTTP-Methods","type":"video","slNo":10,"durationText":"12 minutes"},{"title":"Rest Response","description":"We've looked at requests so far, and understood resource URIs and HTTP methods. Let's switch to responses now.","permalinkName":"Rest-Response","type":"video","slNo":11,"durationText":"16 minutes"},{"title":"HATEOAS","description":"In this tutorial, we'll learn about an important concept relating to REST APIs: HATEOAS\n","permalinkName":"HATEOAS","type":"video","slNo":12,"durationText":"14 minutes"},{"title":"The Richardson Maturity Model","description":"In this tutorial, we'll learn about the Richardson Maturity Model, a way for REST APIs to be classified, and the \"RESTfulness\" of an API determined.","permalinkName":"The-Richardson-Maturity-Model","type":"video","slNo":13,"durationText":"8 minutes"}]}}