{"code":"javaee_jaxrs","desc":"This course introduces you to RESTful Web Services using the JAX-RS standard specification. You will learn what RESTful web services are and how to write them. You will write a sample RESTful web service from scratch, design the APIs, implement it using Jersey and run it on Tomcat. ","img":"https://i.ytimg.com/vi/xkKcdK1u95s/mqdefault.jpg","level":"Beginner","name":"Developing REST APIs with JAX-RS","objectives":["Understanding REST","Learning how to design a REST API","Building a sample social media API","Writing code using Jersey and deploying using Tomcat"],"slNo":1,"tags":["Java","Java EE"],"topic":"javaee","sourceCode":"https://github.com/koushikkothagal/messenger/archive/master.zip","units":{"1":{"courseCode":"javaee_jaxrs","unitDescription":"This unit introduces you to the concept of REST. You'll understand what RESTful web services are and how to design a good REST API.","unitName":"REST API Design","unitNumber":1,"lessons":[{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Welcome to this course. This tutorial introduces you to REST APIs and explains some basic concepts.","permalinkName":"Introduction","title":"Introduction","unitSlNo":"1.1","youtube":"xkKcdK1u95s","duration":996,"slNo":1,"next":"/courses/javaee_jaxrs/lessons/REST-and-HTTP","content":"<h2 id=\"welcome\">Welcome</h2>\n<p>Hello! Welcome to this course on Developing RESTful APIs with JAX-RS. I&#39;m Koushik Kothagal, and in this course, I&#39;ll teach you how to write RESTful web service applications using JAX-RS.</p>\n<p>To learn how to write RESTful APIs using JAX-RS, you&#39;ll need to learn 2 things: First, you&#39;ll need to learn about RESTful APIs or RESTful web services, and second, you&#39;ll need to learn how to implement them using JAX-RS. </p>\n<p>Accordingly, this course is split into two important sections. The first few tutorials in this course introduce you to RESTful web services, explain the concepts and best practices. There are a few standard things to keep in mind when building RESTful web services. You&#39;ll learn about them first. I’ll also walk you through developing a REST API for a sample application. We’ll build a simple social media messaging application through out this course. The application will have some basic functionality of similar sites like Facebook or Google Plus. </p>\n<p>After learning the concepts, we’ll implement some of the features of this social media messaging web service applications using Java and JAX-RS. We&#39;ll add features as we learn more about JAX-RS itself, and we&#39;ll write code as we go, to implement these features.</p>\n<p>Restful web services have recently grown in popularity. I think now is a great time to learn about and work on Restful web services. I hope you are excited to get started!</p>\n<h2 id=\"web-services-in-a-nutshell\">Web services in a nutshell</h2>\n<p>Web services are services that are exposed on the internet for programmatic access. They are online APIs that you can call from your code. To call an API when writing Java code, you add the jars or classes in your class path. Everything executes on a single machine. In the case of web services, you have different pieces of code deployed in different machines and calling methods of each other over the network. </p>\n<p>You must have seen different Facebook or Twitter apps. Or games that can post to your Facebook wall. Even though the games are not designed by Facebook. How can they do that? They do that by calling online APIs. Companies like Facebook  and Twitter publish web services that let other developers call them from their code. So, other application developers can write code to consume these services and do things on Facebook or Twitter itself. </p>\n<p>In a way, they are similar to web pages. For example, Twitter has a web site at twitter.com. When you access it, you get HTML response that lets you read and write tweets. They have some HTML elements for data as well as styling with CSS. That&#39;s because they are meant for humans to read and consume. But, Twitter also has this different URL called api.twitter.com that does a lot of the same things as twitter.com, but it behaves a bit differently. For instance, it does not have HTML and CSS. Any data it returns is in XML or JSON format. And there are specific URLs for different operations. This is what the developers can use from their code, to read data and write data to Twitter. Since it deals with just barebones data, they can just parse the data and build up their objects and data structures. There&#39;s no need for all the fancy HTML and CSS. </p>\n<p>This second part is what we&#39;ll be learning to build in this course. The online APIs. Of course, there are many ways to build such online APIs or web services. One way is to build them as RESTful web services. RESTful web services are a type of web services that are modern, light-weight, and use a lot of the concepts behind HTTP, the technology that drives the web. There is another type of web services that you can choose to write your services in, and that&#39;s called SOAP web services. There is a separate Java Brains course on SOAP web services <a href=\"/courses/javaee_jaxws\">here</a>. This course is going to be about REST.</p>\n<h2 id=\"web-services-characteristics\">Web services characteristics</h2>\n<p>When we talk about web services, there are a few characteristics about them that we have to keep in mind. First, they are <em>web</em> services, so the exchange of data happens over the web. Over HTTP. A client sends an HTTP request, and the server returns back an HTTP response. Similar to web sites. But like we discussed, instead of the response being complete web pages, only the data is returned, because the client is just a program, and not a human. The client could then have it’s own logic to present the data to the users in a presentable format, but the exchange between the web service client and web service server is usually just bare-bones data.</p>\n<p>The next characteristic of web services is the protocol used. Now what’s a protocol? When a web service client makes a request to a web service endpoint, they are usually messages transmitted from one machine to another. These messages need to be in a format, a language, that both the client and the server can understand. This language, or protocol, is standardized in some web service types. For example, SOAP web services is a type of web services, where the protocol always has to follow the standard called SOAP. All SOAP web services uses this protocol to communicate with clients. It used to stand for Simple Object Access Protocol. But that name is now discontinued and we are stuck with just the acronym. There is a specific format, which is XML, and there are specific rules which detail how that XML should be. The client and the server needs to talk to each other using this SOAP protocol <em>only</em>!   </p>\n<p>Ok, so what’s the protocol for REST? Well, there is none! Yes, a REST client can send messages in XML. Or it can send messages in JSON format! Or text format! There are no rules. As long as the client and server understand each other, everybody is happy.</p>\n<p>Secondly, let’s look at how the communication happens. We saw that since RESTful web services are <em>web</em> services, the request and response messages are almost always exchanged over HTTP. But in HTTP, there are different <em>methods</em> available. You would have heard of GET, POST PUT and so on. Which methods to you need to use? What’s the standard for REST? </p>\n<p>Well, the answer is, there is none. Messages can be exchanged in any (or all) HTTP methods. There are guidelines and best practices that tells you what methods need to be used when designing the service, depending on what the request is, but there is no <em>rule</em> as such.</p>\n<p>Let&#39;s look at the next characteristic: service definition. When you are coding and you need to call a method of a library class, you need to know certain things. The name of the class, the method name, the input arguments and so on. When you call web services, a similar concept applies. You need to know what the method does, what the input arguments are and what the return type is. You need to know the <strong>service definition</strong>. In the SOAP web services world, every web service provider publishes a formal document called WSDL that contains all the details that any client would ever need to know about the web service. This is again in XML, and it needs have a specific structure. It contains details about the methods available, the input and output types and so on. Every client has all the details they’d need.</p>\n<p>What’s the formal document that specifies the service definition details for REST web services? I’m pretty sure you can guess the answer to this one. Yes, you are right. There is none! Most Restful web services come with an informal README document written not in XML but in readable English. Many of them don’t even have documentation. In fact, the best RESTful web services would not even need any documentation, formal or informal. We’ll talk about this topic later.</p>\n<p>We could go on with this comparison, but let’s stop here. You get the idea. You are probably wondering if this is really true. Is it really the case? Does the RESTful web services have any <em>rules</em> at all? Could my grandmother have written a RESTful web service? Based on what we have seen so far, anything goes! There are no rules. In contrast, SOAP web services have strict rules for each of these characteristics we&#39;ve seen. So, what’s going on here?</p>\n<p>The reason for this kind of a difference is simple. All SOAP web services follow this thing called the SOAP specification. This specification is a set of rules that dictate what a SOAP web service should be. This was designed by a committee, and it is still maintained by the committee. The specification lays out all the rules, including the rules we just discussed. If a web service doesn’t follow even one of these rules, it is, by definition, <strong>not</strong> a SOAP web service. As simple as that.</p>\n<p>RESTful web services, on the other hand, does not have any specification! It is a concept. An idea. There is no specification, and no committee to tell you what’s right and what’s wrong. The term REST was first introduced by a guy named Roy Fielding in his doctoral thesis back in the year 2000. REST stands for REpresentational State Transfer, and it is not really about web services at all!</p>\n<h2 id=\"representational-state-transfer\">Representational state transfer</h2>\n<p>Representational state transfer is actually an architecture style. Say, you are working on the architecture of a new application. There are certain decisions you’ll need to make. Certain criteria you need to think about. REST consists of a coordinated set of these criteria and constraints that you can use to guide you in the application architecture. It is a set of guidelines. It is a style of architecture.</p>\n<p>You can use this style for any application. However, if you apply this style and these guidelines when architecting a web service, you have <em>drum roll</em> Restful web services. There in lies the difference. Unlike SOAP web services, you don’t have any strict rulebooks to follow when it comes to Restful web services. You can have a spectrum. It is common to hear people say some web service is <em>completely Restful</em>, and some other web service is <em>not fully RESTful</em>. Really! And the goal when building RESTful web services is to make it as <em>RESTful</em> as practically possible. </p>\n<p>In the next tutorials, we’ll start learning more about these constraints and understand what good RESTful web services look like and why.</p>\n","type":"video","durationText":"16 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we will learn some HTTP concepts that have influenced REST.","permalinkName":"REST-and-HTTP","title":"REST and HTTP","unitSlNo":"1.2","youtube":"RuICubxGvj4","duration":844,"slNo":2,"prev":"/courses/javaee_jaxrs/lessons/Introduction","next":"/courses/javaee_jaxrs/lessons/HTTP-Concepts","content":"<p>The concepts of REST are very closely linked with HTTP. HTTP, as you probably know, is everywhere on the internet. Every time you load a web page, you make an HTTP request and you get HTML content in the response.</p>\n<p>REST is inspired by a lot of the concepts of HTTP. Roy Fielding, the one who coined the term, is one of the principal authors of the HTTP specification. So, it’s no surprise that the ideas behind REST make good use of the ideas and concepts behind HTTP. So, to understand REST, you really need to have some basic understanding of HTTP itself. Notice that I said HTTP specification. Yes, specification means <em>rules</em>. What defines HTTP is clearly laid out in the specification, so unlike REST, there is no vagueness about it.</p>\n<h2 id=\"understanding-http\">Understanding HTTP</h2>\n<p>HTTP stands for Hyper Text Transfer Protocol. Like we’ve already seen, you can think of a <em>protocol</em> as a language or mechanism for communication. So, HTTP is a way to exchange and communicate information online.</p>\n<p>The <em>stuff</em> you exchange and transfer in HTTP is called <strong>hypertext</strong>. (Hence the name). Hypertext is a structured form of text that has one interesting property: it contains logical links to other text. These links are called <strong>hyperlinks</strong>. I’m sure you know what they are. A common and popular way to write hypertext is using a language called HyperText Markup Language, or HTML. Which is again something you already know.</p>\n<p>I will not go into the details of HTTP itself, because that’s beyond the scope of this course. Let’s switch to REST. We’ll look at some of the HTTP concepts that have inspired REST, and how those concepts are applied to RESTful APIs and services.</p>\n<h2 id=\"resource-locations\">Resource locations</h2>\n<p>Just like web pages, REST APIs have URLs and addresses too. That way they are similar to web sites. One major difference is, since they are not meant to be read directly by humans, the response usually contains just the core data. For example, if you need to look up a weather for a place on a weather website, you’ll get a response with HTML showing the weather in a readable format. The HTML returned might also have other HTML elements, some CSS for styling, the site banner, some ads on the side and so on. This is because this response is meant to be read by a human. But a REST API response for a weather service probably has just the weather data in XML or JSON.</p>\n<p>Since APIs have addresses, an API designer or web service developer needs to decide what the addresses should be. The practice in RESTful APIs is to have <strong>resource based addresses</strong>. In the case of a weather website, the URI to look up the weather at a zip code 12345 could be something like <code>/weatherapp.com/weatherLookup.do?zipcode=12345</code>. This is a perfectly valid URI, and it is common to see addresses like this too. But this address is not resource based. I would say this is more <em>action based</em>. This tells you that there is something called <code>weatherLookup.do</code> that takes the zip code as parameter. </p>\n<p>Resource based addresses, on the other hand, indicate just the resource and they are independent of the server side implementation. For instance, a RESTful API for weather could have the address <code>/weatherapp/zipcode/12345</code>. It’s almost as if you are not making the server <em>do</em> any action, but rather just <em>look up and get</em> something that already exists. So, weather for zip code 56789 is at <code>/weatherapp/zipcode/56789</code>. And weather forecast for a country could be designed to be at a location like <code>/weatherapp/countries/countryname</code>. In a later tutorial, we will discuss about how to go about designing these addresses when writing REST APIs. This is a very important part of being RESTful.</p>\n<h2 id=\"http-methods\">HTTP methods</h2>\n<p>Now that you have decided what the address is, how do you interact with it? HTTP has what are called <em>methods</em> or <em>verbs</em> that you can use to interact with URLs. You must be familiar with GET and POST methods. A GET method lets you get information from the server. And POST is used when you want to submit information to the server. They work well with resource based URIs that we just saw. So a GET request to URI <code>/weatherapp/zip/12345</code> will get you the weather at that location. There is another method called PUT that you wouldn’t normally use in HTML forms. PUT also lets you submit data to the server, but it is a bit different from POST, and we’ll learn about this later. There’s also a DELETE method that lets you specify that you want something removed.</p>\n<p>A good RESTful web service API makes good use of these HTTP methods. Not all requests are done through POST like a SOAP web service would do. The method that a developer chooses for each API action depends on the action that is performed and the intended use. </p>\n<h2 id=\"metadata\">Metadata</h2>\n<p>Ok, so let’s say we tell the client what the address is and what HTTP method to use to call it. When they make the call, what is the response that we’ll send back? Well, obviously we need to send the response they want. A GET request for the weather URL would have the weather information in the response body. But HTTP also defines status codes and response headers which lets the server send back extra information or metadata that might be useful to the client. One useful piece of information that every response has is the status code. It’s a number that shows up in the very first line of the response. It indicates if the response was successful or if there was an error. If a HTTP response is successful, a <code>200</code> status code is returned. If there is an error on the server while processing the request, the server sends back status code <code>500</code>. If you are trying to access something that does not exist or the server is unable to find, the popular error code <code>404</code> is returned. </p>\n<p>If you are accessing a website, you’ll probably get some HTML that explains the problem. For example, for a <code>404</code> error, you get a page that shows the “page not found” message, probably along with links to the home page to help the user. But in the case of RESTful web services, you cannot send readable messages because the client is a piece of code! This is why sending the right status code is very important. </p>\n<h2 id=\"content-types\">Content types</h2>\n<p>Finally, let’s look at the format of the messages. Let’s say you submit some data to the server as a POST request. There is no specification that strictly enforces what the format of the data should be. It could be XML, JSON or some other format. How can the server even identify what kind of data is sent? Similarly, how does the client know what data format is returned by the server? The answer is again a header value called <code>Content-Type</code>. Like I mentioned, the headers contain a lot of metadata, and one of the metadata values it can contain is the format of the message. There are standard predefined content type values, like <code>text/xml</code> for XML content or <code>application/json</code> for JSON content. A message that’s send with the right content type is easily readable by the server and the client. What’s really interesting is that the same API can send back data in multiple different formats, and the actual format it chooses depends on what the client wants. This happens by a process called content negotiation, which is another powerful feature that you can use when developing RESTful web services.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>This was a broad overview of some of the important points about RESTful web services and how they’ve been influenced by HTTP. When you design a RESTful API:</p>\n<ol>\n<li>You need to have resource-based URIs. Every resource or entity should be identifiable by a single URI.</li>\n<li>You need to choose the right HTTP methods for different actions and operations for the API.</li>\n<li>The response needs to return the right HTTP status codes</li>\n<li>All requests and responses need to have the right <code>Content-Type</code> header set so that the format of the messages are well understood by everyone.</li>\n</ol>\n<p>In the next tutorial, we’ll put these concepts into practice by implementing a RESTful API of our own. These are going to be tutorials on API design. We&#39;ll understand the principles behind good RESTful API design and start designing a RESTful API for the Messenger application</p>\n","type":"video","durationText":"14 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we will learn some HTTP concepts that have influenced REST.","permalinkName":"HTTP-Concepts","title":"HTTP Concepts","unitSlNo":"1.3","type":"quiz","durationText":"5 questions","quizContent":[{"answers":[{"content":"Representational State Transfer"},{"content":"Real-time Embedded Systems Testbed"},{"content":"ReStructuredText"},{"content":"None of the above"}],"correctAnswer":0,"correctAnswerDescription":"REST is short for REpresentational State Transfer","question":"What does REST stand for?","incorrectAnswerDescription":"Rewatch the video if you are not sure!","id":"HTTP-Concepts-0"},{"answers":[{"content":"GET"},{"content":"PUT"},{"content":"POST"},{"content":"DELETE"}],"correctAnswer":0,"correctAnswerDescription":"GET is the method used to request data from the server","question":"Which one of these HTTP methods would you use to make the client request data from the server?","incorrectAnswerDescription":"The key is in the method name!","id":"HTTP-Concepts-1"},{"answers":[{"content":"GET"},{"content":"HEAD"},{"content":"POST"},{"content":"OPTIONS"}],"correctAnswer":2,"correctAnswerDescription":"POST is the only option among the above choices that you can use to submit data.","question":"Which one of these HTTP methods would you use to make the client submit data to the server?","incorrectAnswerDescription":"The key is in the method name!","id":"HTTP-Concepts-2"},{"answers":[{"content":"200"},{"content":"300"},{"content":"400"},{"content":"500"}],"correctAnswer":3,"correctAnswerDescription":"Server errors usually return status 500.","question":"Let's say you handle a request in your web service and there is an error while you process it on the server. Which status code would you return?","incorrectAnswerDescription":"What is the common error code for an internal server error. ","id":"HTTP-Concepts-3"},{"answers":[{"content":"202"},{"content":"303"},{"content":"404"},{"content":"500"}],"correctAnswer":2,"correctAnswerDescription":"When something requested to the API isn't available, APIs usually return status 404.","question":"Let's say you get a request for an item that's not available in the database. Which status code would you return?","incorrectAnswerDescription":"What's the status code for 'Not found'?","id":"HTTP-Concepts-4"},{"answers":[{"content":"text/xml"},{"content":"xml/html"},{"content":"xml/xhtml"},{"content":"None of the above"}],"correctAnswer":0,"correctAnswerDescription":"The content type header for XML content is usually text/xml.","question":"When returning response in XML format, what would be the content type header value you'd need to set in the response?","incorrectAnswerDescription":"","id":"HTTP-Concepts-5"},{"answers":[{"content":"text/json"},{"content":"xml/json"},{"content":"application/json"},{"content":"None of the above"}],"correctAnswer":2,"correctAnswerDescription":"The content type header for JSON content is usually application/json.","question":"When returning response in JSON format, what would be the content type header value you'd need to set in the response?","incorrectAnswerDescription":"","id":"HTTP-Concepts-6"}],"slNo":3,"prev":"/courses/javaee_jaxrs/lessons/REST-and-HTTP","next":"/courses/javaee_jaxrs/lessons/Designing-Resource-URIs"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we’ll start designing a sample RESTful API for our sample social media application. And through the process, we’ll understand how RESTful URIs are designed.","permalinkName":"Designing-Resource-URIs","title":"Designing Resource URIs","unitSlNo":"1.4","youtube":"NjpKwiRORI4","duration":1094,"slNo":4,"prev":"/courses/javaee_jaxrs/lessons/HTTP-Concepts","next":"/courses/javaee_jaxrs/lessons/Resource-URIs","content":"<p>In this tutorial, we’ll start designing a sample RESTful API for our sample social media application. And through the process, we’ll understand how RESTful URIs are designed.</p>\n<p>Note that the next few tutorials are going to be all about design. We will understand what a good API looks like. We will start coding much later, so if you want to get started with the implementation, you can skip these API design tutorials. But remember, an important thing that makes good REST APIs is how well its designed. So, in my opinion, understanding REST API design is more important than learning how to actually implement them.</p>\n<p>The app we are building in this course is gonna be called Messenger. It&#39;s a social media application that lets people post messages as status updates. They can also write comments on other messages or like other messages ala Facebook. Users also have user profile information that they can create and update.</p>\n<p>A very simple application with a very simple ER diagram. You have a USER table with user information. And a MESSAGES table that contains all messages anyone ever posted, each row referring to a USER who posted it. And finally, COMMENTS and LIKES tables which refer to the message that&#39;s being commented or liked. And the user who has entered the comment or hit &#39;like&#39;.</p>\n<p>This is going to be the core of the Messenger application. Let&#39;s look at what URIs you&#39;d design for this application. We want to design RESTful &quot;resource based&quot; URIs. How do we do that?</p>\n<p>If this were to be a web application, I’m sure you already know what to do. Say we need a page to view a message. It takes in a message ID and it displays that message. The URL could be anything of your choice. It could even depend on the framework you use. Let’s say you use Struts. The URI to get post ID 10 could be something like this:\n<code>/MyApp/getMessages.do?id=10</code></p>\n<p>Or it could be:\n<code>/MyApp/retrieveMessages.action?postId=10</code></p>\n<p>These are perfectly valid URIs. And honestly, when developing web applications, what URI you use doesn&#39;t matter. Because, as long as you provide the links to the user in your web app, the user is just going to click on the link and retrieve the message. They rarely have to worry about the URL itself.</p>\n<p>However, when writing REST APIs, the consumers <em>have</em> to be aware of the URIs. This is because, the consumer of your RESTful API is a developer who has to write code to make HTTP calls to the URI. What would really help is have a common URI convention for entities like this. That’s where the RESTful concept of resource URIs come in.</p>\n<p>Before I start explaining the best practices for forming these URIs, I should tell you, that&#39;s what this is: best practice. Like we&#39;ve seen before, there is no right or wrong way to create URIs. But if you are writing a REST API, it&#39;s better you follow these best practices to keep both you, and the API client from going completely insane.</p>\n<h2 id=\"uris-retro-style-\">URIs, retro style!</h2>\n<p>Let’s pause for a minute and step back in time to the late 1980s and early 1990s. The time when bright colors were in fashion everywhere, not just in clothes, but also in web pages. A typical website at that time would most likely be a set of web pages. Static HTML web pages. Imagine one such site now. To access the pages of the site, you would enter the URL that consists of the path to the page ending with the page name. Every page has a specific URI that uniquely identifies that HTML page. There is no ambiguity there. This is exactly the concept behind resource based URIs. Every <em>thing</em> or <em>entity</em> has a URL that’s unique and standard.</p>\n<p>I&#39;ve found the best way to design RESTful URIs is to think of them as static pages. Take the profile pages on a site like Facebook for example. If you had to design profile pages as static HTML, think of how you&#39;d create them. You would create one HTML for every profile. So, if my profile name is koushik, the name of the page would be koushik.html. Let&#39;s say there are 4 users for this website: koushik, raj, sid and jane. So, I have 4 static HTML pages, the names of the files being the names of the profile. Now that I have a bunch of these profile HTML files on my site, I&#39;ll group all the profile pages in a profiles folder. So, the path to my profile page would be something like:</p>\n<p><code>/profiles/koushik.html</code></p>\n<p>Drop the .html extension, and you have the RESTful URI.</p>\n<p><code>/profiles/koushik</code></p>\n<p>Making it generic, the URI for any profile page is:</p>\n<p><code>/profiles/{profileName}</code></p>\n<p>There you have your first RESTful resource based URIs. Think of resources and create a unique URI for them.</p>\n<p>Let&#39;s look at some more examples. How about posts or messages? Let&#39;s say every message has an ID. Then you could design URIs like this:</p>\n<p><code>/messages/{messageId}</code></p>\n<p>So, the URI <code>/messages/1</code> shows you message ID 1 and <code>/messages/10</code> shows message ID 10 and so on.</p>\n<p>Notice two things with the URIs. First, the URI contains <strong>nouns</strong> and not <strong>verbs</strong>. Things in the system like documents, persons, products or accounts are resources. You don&#39;t have URIs like <em>getMessages</em> or <em>fetchMessages</em>. It&#39;s just <em>messages</em>. When you are designing RESTful URIs, keep an eye out for any verbs in your URI. There typically shouldn&#39;t be any. Just nouns. And typically the nouns are the resource names themselves, like posts or profiles. Again, using the static web pages example, you&#39;d never name a directory as getProfiles or fetchMessages. The directory names would be profiles or messages respectively.</p>\n<p>Secondly, notice the resource name is plural in both cases. It&#39;s not <code>/message/{messageId}</code>. Again, this is a good practice, because it makes it clear there are multiple message under <code>/messages</code>, not just one.</p>\n<p>So, here&#39;s the very first step to designing a REST API for any system.</p>\n<blockquote>\n<p>Identify the <em>things</em> or <em>nouns</em> or <em>entities</em> in your system. They are your <em>resources</em>. Then assign resource URIs for each resource.</p>\n</blockquote>\n<p>The advantage of using such resource based URIs is that they are really not dependent of the framework you use. So, no <code>.do</code> or <code>.action</code> in the URIs. And no <code>?id=</code> query params. These details are of no significance to your clients, so there is no reason to have them in the URI. Also, this makes URI resistant to changes in your application design or technology. As W3C says, <a href=\"http://www.w3.org/Provider/Style/URI.html.en\">cool URIs don&#39;t change!</a></p>\n<p>Let&#39;s look at some other <em>nouns</em> in our Messenger application. There&#39;s comments, likes and shares. Each one can be a resource. Let&#39;s start with comments. What would be a good restful URI for a comment with ID 20? Well, it could be <code>/comments/20</code>. That&#39;s correct. But there is one more thing you can do here.</p>\n<h2 id=\"resource-relations\">Resource relations</h2>\n<p>When designing URIs for resources, you&#39;ll often encounter some resources that are dependent on each other. Take the example of messages and comments. Someone posts a message and then other people comment on it. A message can have multiple comments, and each comment has its own IDs. A message has a one-to-many relationship with comments. We&#39;ve designed the URI for posts to be <code>/messages/{messageId}</code>. Could the URI for comments be <code>/comments/{commentId}</code>?</p>\n<p>Well, it could, but that treats messages and comments as two independent resources, and not acknowledge the relationship between them.</p>\n<p>Say we have two messages, message 1 and message 2. Message 1 has comments ID 1, 2 and 3. Message 2 has comments 4 and 5. If I were designing this as static HTML pages, I wouldn&#39;t want to create one comments folder and put all comments pages in it! I would lose the relationship information that comments have to the messages. To convey that relationship, I could create a folder for each message and put all comments pages related to that message in that folder.</p>\n<p>So, the URI for comment 2 is:\n<code>/messages/1/comments/2</code></p>\n<p>Notice how the message ID is a part of the URI, which is then followed by <code>comments</code>  and the comment ID.</p>\n<p>The generic URI for a comment is:\n<code>/messages/{messageId}/comments/{commentId}</code></p>\n<p>Is this URI better than <code>/comments/{commentId}</code>? Well, it depends. This makes it clear that the comment belongs to a particular message, so the relationship between resources is well established. But on the other hand, to get to a comment, you need to know the comment ID as well as the message ID. You know the URI for message ID 20. But what&#39;s the URI for comment ID 300? You&#39;d need to know what the message ID is to access any comment. So, it depends on what you expect your client to know when they need to access this.</p>\n<p>This structure can be applied to other related resources too. For example, message can be shared, and each share has a unique ID. So, the URI for likes could be:</p>\n<p><code>/messages/{messageId}/likes/{likeId}</code></p>\n<p>A share could be:</p>\n<p><code>/messages/{messageId}/shares/{shareId}</code></p>\n<p>So, typically, when there is a one-to-many relationships, you could choose to have the &quot;one&quot; side of the relationship to be the root resource, and then the resource on the &quot;many&quot; side follow that.</p>\n<p>How about many-to-many? Or one-to-one? Let&#39;s set that aside for now. We will revisit relationships later in this course, and for now, let&#39;s limit ourselves to one-to-many.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>So, what are the resources in our system? We have profiles, messages, comments, likes and shares. We have identified resource URIs for each. We&#39;ll treat profiles and messages as first level entities, and comments, likes and shares as second level entities in relation to messages.</p>\n<p>Now you might wonder why messages are not related to profiles. Why are they both first level entities? Messages are posted by someone who has a profile. There is a one to many relationship between profile and messages! So, couldn&#39;t you have message URIs like this?</p>\n<p><code>/profiles/{profileId}/messages/{messageId}</code></p>\n<p>You could! In this case, I decided to have messages independent of profiles because I felt they weren&#39;t as tightly coupled together as messages and comments are. But this is something that you should decide when designing the API for your system.</p>\n<p>I hope the concept of resource based URIs makes sense. One other important consideration is a concept of collection URIs, which we&#39;ll learn about in the next tutorial.</p>\n","type":"video","durationText":"18 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we’ll start designing a sample RESTful API for our sample social media application. And through the process, we’ll understand how RESTful URIs are designed.","permalinkName":"Resource-URIs","title":"Resource URIs","unitSlNo":"1.5","type":"quiz","durationText":"3 questions","quizContent":[{"answers":[{"content":"<code>/getCategories</code>"},{"content":"<code>/fetchCategories?categoryId={categoryId}</code>"},{"content":"<code>/categories</code>"},{"content":"<code>/categories/{categoryId}</code>"}],"correctAnswer":3,"question":"Let's say you need to build RESTful URIs for various resources in an online shopping site. Say you have <code>Category</code> as an entity that represents all the product categories on the site. What would be a RESTful URI to lookup a category with ID <code>categoryId</code>?","id":"Resource-URIs-0"},{"answers":[{"content":"<code>/products</code>"},{"content":"<code>/products?id=25</code>"},{"content":"<code>/products/25</code>"},{"content":"<code>/products/id/25</code>"}],"correctAnswer":2,"question":"The site also has a <code>Product</code> entity. This has been designed to be a first level entity like <code>Category</code>. What would be a good RESTful URI for a product with ID 25?","id":"Resource-URIs-1"},{"answers":[{"content":"<code>/categories/products</code>"},{"content":"<code>/categories/products/{productId}</code>"},{"content":"<code>/categories/products/{categoryId}/{productId}</code>"},{"content":"<code>/categories/{categoryid}/products/{productid}</code>"}],"correctAnswer":3,"question":"If the <code>Product</code> entity were to have been designed as a sub-resource under the <code>Category</code> entity, what would the URI for <code>Product</code> be?","id":"Resource-URIs-2"}],"slNo":5,"prev":"/courses/javaee_jaxrs/lessons/Designing-Resource-URIs","next":"/courses/javaee_jaxrs/lessons/RESTful-URI-types","content":"<hr>\n"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"You can think of RESTful URIs as belonging to two types: instance resource URIs and collection resource URIs. Let's understand what they mean.","permalinkName":"RESTful-URI-types","title":"RESTful URI types","unitSlNo":"1.6","youtube":"gYKJqUZXuBw","duration":452,"slNo":6,"prev":"/courses/javaee_jaxrs/lessons/Resource-URIs","next":"/courses/javaee_jaxrs/lessons/URI-types","content":"<h2 id=\"uri-types\">URI Types</h2>\n<p>We&#39;ve designed URIs for messages and comments in the previous tutorial. To recap, a message is accessible at:\n<code>/messages/{messageId}</code></p>\n<p>And comments are accessible at:\n<code>/messages/{messageId}/comments/{commentId}</code></p>\n<p>These URIs are great when you want to look up a particular message or a particular comment. These are called instance resource URIs. A single instance of a message or a comment is accessible by the instance resource. Instance resource URIs typically have a unique ID of that resource to identify which instance you are interested in.</p>\n<p>What about if you want all messages?</p>\n<p>The answer is simple. Just access \n<code>/messages</code></p>\n<p>That&#39;s it! Again, this is analogous to a simple static site with HTML pages. Accessing a directory gives you all the contents in that directory. So, think of <code>/messages</code> as the top level directory for all messages and accessing that URI gives a list of all messages.</p>\n<p>Similarly, if you need all comments made for message 2, the URI is: <code>/messages/2/comments</code>. That&#39;s the directory for all comments for message 2.</p>\n<p>These URIs are different from the URIs we saw in the previous tutorial. They do not represent a particular resource, but rather, a collection or a list of resources. So, they are called <em>collection URIs</em>. These URIs pull up a collection of instance resources. </p>\n<p>This also explains why the resource names are in plural. They help the client understand that they are working with a collection of resources with these URIs.</p>\n<p><code>/messages</code> returns all messages\n<code>/profiles</code> returns all profiles\n<code>/messages/{messageId}/comments</code> returns all comments for <code>messageId</code>\n<code>/messages/{messageId}/likes</code> returns all likes for <code>messageId</code>\n<code>/messages/{messageId}/shares</code> returns all shares for <code>messageId</code></p>\n<p>This shows you the advantage of <em>nesting</em> related resources like messages and comments, or messages and likes in this way. But this also brings up a problem. What if you need a list of <em>all</em> comments irrespective of which message they are associated with. This URI is not good enough for that. The way we have designed our URI, you have to give a message ID here. This is where a decision has to be made about how you want resources to be accessed. In this example, I choose to not provide an option for getting all comments. A comment makes sense only in the context of a message, and I don&#39;t want my clients to make requests for all comments. If I needed to provide that functionality, I would design the comments URI like <code>/comments</code> rather than <code>/messages/{messageId}/comments</code>. Again, no right or wrong. This is something you decide.</p>\n<h2 id=\"filtering-collections\">Filtering collections</h2>\n<p>When you have collection URIs like this, you&#39;d want a way to filter the result. It&#39;s not so much a problem for the comments URI. Getting all comments for a message is mostly not going to be a big list, but imagine getting all messages. That&#39;s going to result in a lot of data, and the client who&#39;s making the request probably doesn&#39;t want all that data. We should design our API to provide a way for the client to paginate or filter the results. </p>\n<p>One way to do that is using query params. We have so far avoided query params in our URIs, but filtering and pagination is a good scenario to use them. One standard practice to provide pagination is to have two query params: starting point and page size. </p>\n<p>For example, consider this URI:</p>\n<p><code>/messages?offset=30&amp;limit=10</code></p>\n<p>This URI fetches messages starting from message number 30 and returns the next 10 messages. The offset and limit params correspond to the start and page size values. The offset param tells you where client wants to start, and the limit tells you how many records the client wants. This, of course, assumes a specific order in which messages are returned, whether it is chronological or ID based. You as an API developer needs to make sure that the order that&#39;s returned is the same: The order in which you responded to the request for the first page should be retained in the requests for the second page.</p>\n<p>The client who uses your API might have their own logic for displaying pagination controls on their UI. But they would use these two params to make calls to the RESTful service to get chunks of data in pages.</p>\n<p>You can also choose to implement other kinds of filters using query params. Take an example of retrieving messages based on date. Let&#39;s say you want to provide an ability for clients to retrieve messages posted in a given year. You could have them send request like this:</p>\n<p><code>/messages?year=2014</code></p>\n<p>This returns all messages made in the year 2014. This is of course, something you can use together with pagination like this:</p>\n<p><code>/messages?year=2014&amp;offset=50&amp;limit=25</code></p>\n<h2 id=\"summary\">Summary</h2>\n<p>There are two types of REST URIs. One is instance resource URIs that identify a specific resource, and the other is collection URI which represent a collection of resources. Collection URIs usually end in plurals, like <em>messages</em>, <em>comments</em>, <em>products</em> and so on, and are typically a portion of the resource URI. An instance resource URI identify a specific resource below a collection resource URI.</p>\n<p>And finally, you can implement query params as a way of achieving pagination and filtering when accessing collection URIs.</p>\n<p>I encourage you to do the exercises where you&#39;ll practice writing RESTful URIs for collection resources. I&#39;ll see you in the next video.</p>\n","type":"video","durationText":"7 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"You can think of RESTful URIs as belonging to two types: instance resource URIs and collection resource URIs. Let's understand what they mean.","permalinkName":"URI-types","title":"URI types","unitSlNo":"1.7","type":"quiz","durationText":"4 questions","quizContent":[{"answers":[{"content":"<code>/getCategories</code>"},{"content":"<code>/fetchCategories?categoryId={categoryId}</code>"},{"content":"<code>/categories</code>"},{"content":"<code>/categories/{categoryId}</code>"}],"correctAnswer":2,"question":"Let's say you have <code>Category</code> as an entity that represents all the product categories on the site. What would be a RESTful URI to look up all categories?","id":"URI-types-0"},{"answers":[{"content":"<code>/products</code>"},{"content":"<code>/products?action=GET</code>"},{"content":"<code>/getAllProducts</code>"},{"content":"<code>/products/all</code>"}],"correctAnswer":0,"question":"The site also has a <code>Product</code> entity. This has been designed to be a first level entity like <code>Category</code>. What would be a good RESTful URI for all products?","id":"URI-types-1"},{"answers":[{"content":"<code>/categories/products</code>"},{"content":"<code>/categories/products/{productId}</code>"},{"content":"<code>/categories/products/{categoryId}</code>"},{"content":"<code>/categories/{categoryid}/products</code>"}],"correctAnswer":3,"question":"If the <code>Product</code> entity were to have been designed as a sub-resource under the <code>Category</code> entity, what would the URI for <code>Product</code> be?","id":"URI-types-2"}],"slNo":7,"prev":"/courses/javaee_jaxrs/lessons/RESTful-URI-types","next":"/courses/javaee_jaxrs/lessons/HTTP-Methods"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Now that we've identified some important resource URIs, let's work on the operations that can be performed and the data that's exchanged.","permalinkName":"HTTP-Methods","title":"HTTP Methods","unitSlNo":"1.8","youtube":"AK6TulIASgQ","duration":665,"slNo":8,"prev":"/courses/javaee_jaxrs/lessons/URI-types","next":"/courses/javaee_jaxrs/lessons/HTTP-Methods-Quiz","content":"<p>We saw that a URI like <code>getMessages.do?id=10</code> is <em>action-based</em> and not RESTful. We chose the URI <code>/messages/10</code> to replace it. This is resource based and RESTful and all that good stuff. But here&#39;s a problem.</p>\n<p>Look at the URI <code>getMessages.do?id=10</code>. It has 3 pieces of information. </p>\n<ol>\n<li>It refers to messages</li>\n<li>It refers to ID 10</li>\n<li>It <em>gets</em> that information</li>\n</ol>\n<p>Now look at the URI <code>/messages/10</code>. There&#39;s definitely #1 and #2. But the URI does not have the information in point 3.</p>\n<p>You could argue that accessing that URI <em>gets</em> the data for message id 10. But what about other operations? We have looked at just getting data so far. You could have URIs that submit data.</p>\n<p>For example:\n<code>/submitMessage.do?id=10</code> lets you submit something to the message ID 10. What would be the REST URI equivalent for that?</p>\n<p>Well, equivalent resource based REST URI is:\n<code>/messages/10</code></p>\n<p>Yes, that&#39;s right! It&#39;s the same URI.</p>\n<p>How about a delete operation? What would be the equivalent of a URI like <code>/deleteMessage.do?id=10</code>?</p>\n<p>The equivalent is still <code>/messages/10</code>!</p>\n<p>How is that possible? How can the same URI do all these different operations? <em>And how does it know when to do what?</em></p>\n<p>The answer is <strong>HTTP methods</strong>. If you want your API client to perform different operations for message 10, just have them use different HTTP methods to the same URI <code>/messages/10</code>! </p>\n<p>The most common HTTP methods are:</p>\n<ol>\n<li>GET</li>\n<li>POST</li>\n<li>PUT</li>\n<li>DELETE</li>\n</ol>\n<p>There are some other methods that are rarely used like HEAD and OPTIONS. But for the most part, we&#39;ll focus on the 4 common HTTP methods in this course.</p>\n<p>These HTTP methods have specific meanings, and you typically use the right method for the right operation. Also, when using HTTP, like when you are browsing a web page, you are actually using these methods automatically. When you type in a URL in the address bar of your browser, the browser automatically issues a GET request for that URL. When you submit a form, the browser probably uses a POST request to do so. The idea is to use the right methods depending on the operation. Choosing methods for a RESTful API also follows the same idea.</p>\n<p>So, for example, in the REST world, you do not make a call to <code>getProducts</code>. You make a GET request to the products resource URI. You do not call <code>deleteOrder</code>. You make a DELETE request to the order resource URI. The URI tells you what <em>entity</em> or resource is being operated upon and the method tells you what the operation is.</p>\n<h2 id=\"scenarios\">Scenarios</h2>\n<p>Let us look at some of the common operations in our sample social media application and identify the HTTP methods for each of them.</p>\n<h4 id=\"getting-a-message\">Getting a message</h4>\n<p>This should be obvious now. The URI is the resource URI that you need to get. the HTTP method is GET, since you are literally <em>getting</em> the information</p>\n<p>Example: <code>GET /messages/20</code> returns the message ID 20.</p>\n<h4 id=\"updating-a-message\">Updating a message</h4>\n<p>Let&#39;s say our social media application lets you make changes to messages you&#39;ve already submitted. We anticipate this feature of our Messenger application will be very popular  among some  celebrities and politicians who&#39;d sometimes like to retract what they&#39;ve already posted. </p>\n<p>What&#39;s the right method for submitting an updated message. Is it the POST method? This one is not all that obvious. You <em>can</em> use POST, and I know some people do, but the standard practice is to use the PUT method. Why PUT and not POST? There is a very important difference between two, and I&#39;ll talk about that a bit later. But for now, remember that we&#39;ll be using PUT to <em>update</em>  or <em>change</em> any resource. </p>\n<p>Of course, you&#39;ll want the resource to be updated with something. The new content. That content needs to be sent in the body of the PUT request. </p>\n<p>Example: <code>PUT /messages/20</code> (with the request body containing the new message content) replaces the message ID 20 with the content in the request body.</p>\n<h4 id=\"deleting-a-message\">Deleting a message</h4>\n<p>This one should be easy. Yes, there is a DELETE method, and that&#39;s what you should use here. When you want your clients to delete a resource, just have them issue a DELETE request to the resource URI.  No request body required.</p>\n<p>Example: <code>DELETE /messages/20</code> deletes message ID 20.</p>\n<h4 id=\"creating-a-new-message\">Creating a new message</h4>\n<p> This one is interesting. Before we talk about the method to use, think about what URI to call to create a new message. To get, change or delete a message, you used the message resource URI <code>/messages/{messageId}</code>. How about creating a new message? The message hasn&#39;t been created yet, so there is no message ID! And the ID is typically managed by the application, by finding the next unused ID, so the client usually has no idea what the ID will be.</p>\n<p>This is why, requests for creating a new resource is always issued to the collection URI for that resource. To create a new message, the request is made to <code>/messages</code>. To create a new profile, a request is made to <code>/profiles</code>. The application receives this request and creates a new resource and assigns an ID to it.</p>\n<p>With that settled, what will be the HTTP method? For creating resources, the practice is to use a POST method. The POST body will should contain the content for creating the resource.</p>\n<p>Once the resource is created, the service will need to let the client know what the ID is. Because, unless the client knows the ID, there is no way for it to do anything with the newly created resource. So, in the response for the POST request, the web service sends back the ID of the newly created resource.</p>\n<p>Example: <code>POST /messages</code> (with the request body containing the new message) creates a new message with the content in the request body. Response to this request contains the message ID that was created.</p>\n<h2 id=\"collection-uri-scenarios\">Collection URI scenarios</h2>\n<p>You&#39;ll appreciate the elegance and overall awesomeness of REST API practices when you realize how seamlessly these concepts translate to collection URIs.</p>\n<p>Imagine what happens when you make a GET request to a collection URI like <code>/messages</code>. Yes, you get all messages! Other HTTP methods work the same way too. Here are some examples:</p>\n<p>DELETE on <code>/messages/10/comments</code> deletes all comments associated with message 10.</p>\n<p>POST on <code>/messages/10/comments</code> creates a new comment for message ID 10 with the request body containing the new comment information.</p>\n<p>PUT on <code>/messages/20/comments</code> replaces the list of comments for message ID 20 with a new list of comments in the PUT body. (This kind of API is not commonly used though)</p>\n<p>DELETE on <code>/messages</code> deletes all messages (Again, not commonly used, and not something you&#39;d want to implement, I think!)</p>\n<h2 id=\"summary\">Summary</h2>\n<p>There you go. We have identified standard HTTP methods for all the CRUD operations. Whenever you need to provide APIs for creating, deleting, fetching or updating a resource, you know what methods to choose for them.</p>\n<p>This, of course, doesn&#39;t address all the operations. Very rarely do web applications perform just CRUD operations. What if you need to provide an API for archiving a message? Or run a server-side job? How can we map GET, PUT, POST and DELETE methods to those miscellaneous operations?</p>\n<p>The fact is, these methods do not really map to CRUD operations. It does look like that based on what we&#39;ve seen in this tutorial, but there is more to it. We will talk about this in a later tutorial, so hold on to that thought for a bit!</p>\n","type":"video","durationText":"11 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Now that we've identified some important resource URIs, let's work on the operations that can be performed and the data that's exchanged.","permalinkName":"HTTP-Methods-Quiz","title":"HTTP Methods Quiz","unitSlNo":"1.9","type":"quiz","durationText":"3 questions","quizContent":[{"answers":[{"content":"<code>/products</code>"},{"content":"<code>/products?action=GET</code>"},{"content":"<code>/getAllProducts</code>"},{"content":"<code>/products/all</code>"}],"description":"The site also has a <code>Product</code> entity. This has been designed to be a first level entity like <code>Category</code>. What would be a good RESTful URI for all products?","id":"HTTP-Methods-Quiz-0"},{"answers":[{"content":"<code>DELETE -> /products</code>"},{"content":"<code>DELETE -> /products/id</code>"},{"content":"<code>/products/id/delete</code>"},{"content":"<code>None of the above</code>"}],"description":"Which of these is a good choice for deleting a Product instance?","id":"HTTP-Methods-Quiz-1"},{"answers":[{"content":"<code>POST -> /products</code>"},{"content":"<code>POST -> /products/id</code>"},{"content":"<code>PUT -> /products/id</code>"},{"content":"<code>None of the above</code>"}],"description":"Which of these is a good choice for updating a Product instance?","id":"HTTP-Methods-Quiz-2"},{"answers":[{"content":"<code>POST -> /products</code>"},{"content":"<code>POST -> /products/id</code>"},{"content":"<code>PUT -> /products/id</code>"},{"content":"<code>None of the above</code>"}],"description":"Which of these is a good choice for creating a new Product?","id":"HTTP-Methods-Quiz-3"}],"slNo":9,"prev":"/courses/javaee_jaxrs/lessons/HTTP-Methods","next":"/courses/javaee_jaxrs/lessons/Idempotence-In-HTTP-Methods"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Idempotence. Yes, that's a word. And it's an important property of HTTP methods according to the specifications.","permalinkName":"Idempotence-In-HTTP-Methods","title":"Idempotence In HTTP Methods","unitSlNo":"1.10","youtube":"rhTkRK53XdQ","duration":722,"slNo":10,"prev":"/courses/javaee_jaxrs/lessons/HTTP-Methods-Quiz","next":"/courses/javaee_jaxrs/lessons/Rest-Response","content":"<p>Idempotence. Yes, that&#39;s a word. And it&#39;s an important property of HTTP methods according to the specifications.</p>\n<h2 id=\"put-vs-post\">PUT vs POST</h2>\n<p>When I was learning about RESTful web services, one thing that confused me was the difference between PUT and POST. Like we&#39;ve already seen, you use PUT when you want to update an existing resource, and POST when you want to create a new resource. But if you search online, you will very likely find a lot of resources that contradict each other. Some are plain wrong, while others tell you the right thing to do, but do not explain why. I&#39;ll try to explain this difference and hopefully, it&#39;ll be clear to you by the time you are done with this tutorial.</p>\n<h2 id=\"method-classification\">Method classification</h2>\n<p>There are two ways in which we can classify these 4 popular HTTP methods: GET, PUT, POST and DELETE. The GET method is a <em>read-only</em> method; it lets you read information. But the methods PUT, POST and DELETE are <em>write</em> methods; they change something on the server. They either create, update or delete, but they all cause something to change on the server. </p>\n<p>So, it is safe to assume that you can make a GET request as many times as you want without having any <em>impact</em> on the server. You should never have a GET method do things like updates or deletes.</p>\n<p>For example: GET on <code>/messages/20/delete</code>. <strong>Never do this!</strong></p>\n<p>Nothing changes when you do a GET, so it&#39;s safe to make multiple requests and not worry about the side effect. But how about PUT, POST and DELETE? Since they are methods that <em>write</em> to the server, you obviously cannot make those calls multiple times!  Or can you?</p>\n<p>Just because an operation is not read-only, it doesn&#39;t automatically mean that it cannot be duplicated.</p>\n<p>Take an example of a Java assignment statement. Assume <code>count</code> is an <code>integer</code> variable</p>\n<pre><code class=\"lang-java\">count = 100;\n</code></pre>\n<p>This is definitely not a read-only operation. This statement writes a value 100 to the variable <code>count</code>. However, if you were to repeat this operation three times, lines 2 and 3 do not really do anything. Well, maybe they do write the value to the variable, but for all practical purposes, they do not have any effect.</p>\n<pre><code class=\"lang-java\">count = 100;\ncount = 100;\ncount = 100;\n</code></pre>\n<p>This nature of some operations that let them be <em>repeatable</em> is important in HTTP methods. Like we saw, GET is clearly a repeatable operation, because it is read-only. </p>\n<p>Let&#39;s take DELETE. Say you make a DELETE request to <code>/messages/10</code>. This deletes message ID 10. Say you make the same call again. Well, message 10 is already deleted. So nothing happens. While it isn&#39;t really required or desirable to make multiple DELETE calls to the same resource, you can see that it is at least not a problem. There are no unwanted side effects if you were to make a duplicate call by mistake.</p>\n<p>Ok, how about PUT. Say you make a PUT request to <code>/messages/20</code> with some message text in the request body. This is going to replace whatever message ID 20 was with this new message text that&#39;s being sent in the request body. Say you make the exact same call again. Message ID 20 is again replaced with the exact same message text again. Make the same request the third time, and the result is the same. Guess what? Even a PUT is <em>safe</em> when it comes to making multiple calls. If you were to accidentally repeat a PUT request, well, don&#39;t worry about it. The final saved message remains the same after every request.</p>\n<p>The problem, however, is with the POST request. If you were to make a POST request to <code>/messages</code>, you create a new message. Say you forgot you made a POST request, and you issued the request again, and now you&#39;ve actually created a duplicate message. Repeat that call, and you get another message! So every time a POST request is made, something new happens. This is clearly not a <em>safe</em> method to make multiple calls with. Every duplicate call changes things by creating a new resource. It&#39;s definitely not a good idea to make multiple POST calls, unless you actually need multiple resources.</p>\n<p>So, we have another way to classify HTTP methods into two types. One set of methods, including GET, PUT and DELETE,  are <em>safe</em> for make repeated calls without worrying about the impact. They may not all be read-only. But they do not cause side-effects if called multiple times. And the other category, consisting of POST which you have to be very careful with, and make only as many calls as you need. The methods in the first set are called <strong>idempotent</strong> methods. GET, PUT and DELETE are idempotent. POST is <strong>non-idempotent</strong>.</p>\n<p> Here&#39;s the Wikipedia definition of <em>idempotence</em></p>\n<blockquote>\n<p>Idempotence is the property of certain operations in mathematics and computer science, that can be applied multiple times without changing the result beyond the initial application.</p>\n</blockquote>\n<p>The HTTP specification requires GET, PUT and DELETE methods to always be idempotent. If a client makes a request with one of these methods, they do not have to worry about making duplicate requests. But if they are making a POST request, they <em>cannot</em> safely make duplicate requests without any side effects.</p>\n<p>Which is why resource creation should be a POST method. Because resource creation requests are not idempotent. Which is because multiple requests to create resources results in multiple resources. But updating a resource, like we saw, can be called multiple times safely. Which is why update requests ideally use the HTTP PUT method, which is supposed to be idempotent as per the specification.</p>\n<p>The <em>only</em> way you can safely use PUT for creating a new resource is in scenarios where the client specifies the new ID of the resource being created. In which case, the client sends the request for creating a resource to the actual instance resource URL that includes the ID. If you were to implement this, then resource creation request is idempotent. Think about it. If you repeat the request, since it has the ID in it, it doesn&#39;t create a new resource. Perhaps, the resource with the ID is re-created or updated. This is the only scenario where you can use PUT for creating resources. But in most cases, when you have the server creating IDs and you issue a create resource request to the collection URI, you&#39;d want to use POST.</p>\n<p>Like I&#39;ve mentioned before, these methods have standard meanings. The fact that this is a standard means that if you ignore it when implementing your APIs, you&#39;ll confuse your clients or cause their code to function improperly. Also, a common thing that many APIs do is cache some of their GET responses. When a client makes a GET request, it also updates the cache, and another GET request to that same resource URI within a certain period of time will be served directly from the cache, thereby increasing performance. This works only because GET doesn&#39;t change anything on the server, so it is <em>cacheable</em>. You can definitely build an API that creates new resources when your clients call GET, but if you do that, you&#39;ll not have many clients using your API for long! </p>\n<p>On the other hand, if you choose proper methods, your clients can build safeguards to make sure duplicate requests do not happen. Take the example of a browser refresh button. Every browser has a refresh or reload button that does a very simple function: resend the last HTTP request that was made by the browser. If the last request happens to be an idempotent request like a GET, the browser just goes ahead and resends the request when you hit refresh. But if it was a POST, like after you&#39;ve submitted a form, if you hit refresh, the browser warns you with a message that says something like &quot;You&#39;ve already submitted this data before. Are you sure you wish to resubmit?&quot;. This is simply the browser protecting you from making a duplicate non-idempotent request. So, it pays to generally use the right HTTP method for the right operation.</p>\n<p>In this tutorial, you learned about what idempotent and non-idempotent requests are. Make sure you keep these concepts in mind when you choose HTTP methods for your APIs.</p>\n","type":"video","durationText":"12 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"We've looked at requests so far, and understood resource URIs and HTTP methods. Let's switch to responses now.","permalinkName":"Rest-Response","title":"Rest Response","unitSlNo":"1.11","youtube":"ZyuPCYB-n5o","duration":993,"slNo":11,"prev":"/courses/javaee_jaxrs/lessons/Idempotence-In-HTTP-Methods","next":"/courses/javaee_jaxrs/lessons/HATEOAS","content":"<p>We&#39;ve looked at requests so far, and understood resource URIs and HTTP methods. Let&#39;s switch to responses now.</p>\n<h2 id=\"from-requests-to-responses\">From requests to responses</h2>\n<p>We&#39;ve learned where to make requests (resource URIs) and how to make requests (HTTP methods). Time to look at responses now. When a request comes in, what should the REST web service respond with? Knowing what the client will get back from the server is an important part of the API, because the client needs to write code to handle the response.</p>\n<p>If it were a web application, we know  the response is usually an HTML page. With styling, formatting and also, of course, the actual data in a presentable format. But when it comes to RESTful web services, you don&#39;t need to do all the styling and formatting anymore. You just need to send the actual data. How do you send it?</p>\n<p>We discussed about various standard formats that responses can be sent in, like XML and JSON. JSON has been growing in popularity, because it is much more compact and less verbose when  compared to XML, especially when large data is involved. Also, more often than not, a client to a RESTful API is client side Javascript code, and sending back data in JSON means it can easily convert it to a Javascript object. Considering these advantages, we&#39;ll choose JSON as response for our social media application in this course. However, note that you do not typically need to settle for just one format. You can write APIs to support multiple response formats, and we will implement one such API endpoint later in this course to illustrate that.</p>\n<h2 id=\"formats\">Formats</h2>\n<p>Let&#39;s say our Message entity class has these four member variables: the id, the text of the message, when it was created and who created it.</p>\n<pre><code class=\"lang-java\">public class MessageEntity {\n    private long id;\n    private String message;\n    private Date created;\n    private String author;\n...\n}\n</code></pre>\n<p>When a GET request is made for a specific message, say message ID 10, the JSON that you would return would look something like this:</p>\n<pre><code>{\n    &quot;id&quot;:&quot;10&quot;,\n    &quot;message&quot;:&quot;Hello world&quot;,\n    &quot;created&quot;:&quot;2014-06-01T18:06:36.902&quot;,\n    &quot;author&quot;:&quot;koushik&quot;\n}\n</code></pre><p>But the response doesn&#39;t <em>have</em> to be JSON. You could return XML as well, if the client asks for it in XML format.  We haven&#39;t yet covered how a client can <em>ask</em> for a specific format. We&#39;ll be looking at that later. But yes, a client can say &quot;I need a JSON response&quot; or &quot;Give me an XML response&quot;.  Here is a possible XML response for the same message ID 10.</p>\n<pre><code>&lt;messageEntity&gt;\n    &lt;id&gt;10&lt;/id&gt;\n    &lt;message&gt;Hello world&lt;/message&gt;\n    &lt;created&gt;2014-06-01T18:06:36.902&lt;/created&gt;\n    &lt;author&gt;koushik&lt;/author&gt;\n&lt;/messageEntity&gt;\n</code></pre><p>Clearly the JSON response and the XML response are different. But they represent the same resource: message ID 10. So, in other words both these responses are different representations of the same resource. This is a very important thing to remember. When you make REST API calls you are sending or receiving <em>representations</em> of the resource. Different representations could have different formats, even though the underlying resource is the same. This is actually how REST gets its name. Representational State Transfer.  You are transferring the representational state.</p>\n<blockquote>\n<p>When you make REST API calls you are sending or receiving <em>representations</em> of the resource.</p>\n</blockquote>\n<h2 id=\"message-headers\">Message Headers</h2>\n<p>Ok, so it&#39;s great that a REST web service can return data in XML or JSON. But that brings up a problem. How does the client know what format the response is in? The client can of course request data in a particular format, but there&#39;s no guarantee that the service responds in that format. Say, a client request asks for XML. But if the REST service knows only JSON, it does return JSON ignoring the client&#39;s preference for XML. How does the client know the format then?</p>\n<p>The answer is using HTTP headers. The HTTP protocol has a concept of request and response headers. Every HTTP request or response has a body, which is the message itself, and certain header values that contain metadata about the message. The header data could be stuff like the content length and date. One such possible header is <code>Content-Type</code>. The response could contain the Content-Type header with the value for JSON or XML. There are special values for JSON and XML, and we&#39;ll learn more about that when we implement this, but for now, know that the type of content is being sent back as a response header. The client can then examine this header value and then parse the response body content accordingly.</p>\n<h2 id=\"status-codes\">Status codes</h2>\n<p>Think about error messages in a web application. Whens something goes wrong, the application typically returns a page with an error message, maybe in bold red text. Even if it isn&#39;t in red, the message itself would give the user an idea that it&#39;s an error. But in the case of REST APIs, since the consumer is not a human, we need to provide some set of codes to the consumer to help them identify error scenarios. </p>\n<p>HTTP specification requires the very first line of any response to be a <em>status line</em>. This line will have a numerical code and a short phrase explaining what the code means. This is not just for errors. Every HTTP response needs to have this line. If the response is successful, the very first line of the response will be:\n<code>200 OK</code></p>\n<p>Let&#39;s take the familiar 404 error code. If a request is made on a URI, for example <code>/messages/101</code> and there is no message available with ID 101, the first line of the response should be:\n<code>404 Not Found</code></p>\n<p>Again, the code <code>404</code> is for the client code to read and act. The phrase <code>Not Found</code> is an aid to the programmer, in case they forget what the code means. Not that any programmer would ever forget what <code>404</code> means. I mean, come on!</p>\n<p>There are a bunch of codes that are important for us to remember and use when developing a REST API. The error codes start from 100 and go up to 599. Not all of them are valid error codes though, so you don&#39;t have 500 different possible error codes. There are 5 classes of status codes and the first digit indicates what class the code belongs to: 1 to 5.</p>\n<h2 id=\"1xx-codes-informational\">1XX Codes - Informational</h2>\n<p>The codes starting with 1XX are informational, like acknowledgement responses. We&#39;ll not be using this set of codes in this course.</p>\n<h2 id=\"2xx-codes-success\">2XX Codes - Success</h2>\n<p>The codes starting with 2XX are success codes. This indicates that the server received the request from the client and processed it successfully. Some examples:</p>\n<h3 id=\"200-ok\">200 OK</h3>\n<p>Indicates successful response. You&#39;d return this for any request that you can successfully respond to.</p>\n<h3 id=\"201-created\">201 Created</h3>\n<p>Indicates successful resource creation. Say you get a POST request for a collection URI like <code>/messages</code> and you successfully create a new message. You could return <code>200 OK</code> to indicate success, but a better response code would be <code>201 Created</code>.</p>\n<h3 id=\"204-no-content\">204 No Content</h3>\n<p>Sometimes the server receives requests that need it to do something, but it doesn&#39;t need to return any content back. Like DELETE requests, for example. In this case, you could either return <code>200 OK</code> with no response content. Or return <code>204 No Content</code>, which makes it obvious that the server really intends to send nothing back.</p>\n<h2 id=\"3xx-codes-redirection\">3XX Codes - Redirection</h2>\n<p>The server sends these codes to ask the client to do further action to complete the request. For example, it could be a redirect, asking the client to send the request somewhere else. </p>\n<h3 id=\"302-found-and-307-temporary-redirect\">302 Found and 307 Temporary Redirect</h3>\n<p>One of these two error codes are returned by the server if it wants the client to request elsewhere. It&#39;s a redirect.</p>\n<h3 id=\"304-not-modified\">304 Not Modified</h3>\n<p>When a client tries to get a resource that it has already got before, the server can send this status code to say &quot;I&#39;ve already given you this resource a little while back, and nothing has changed since then.&quot;</p>\n<h2 id=\"4xx-codes-client-error\">4XX Codes - Client error</h2>\n<p>These error codes are returned if the client makes an error in the request. The request syntax could have been incorrect, or the client is requesting something that it&#39;s not supposed to see.</p>\n<h3 id=\"400-bad-request\">400 Bad Request</h3>\n<p>This is a client error. The server is not able to understand the request</p>\n<h3 id=\"401-unauthorized\">401 Unauthorized</h3>\n<p>The request needs the client to <em>sign in</em> or authorize themselves.</p>\n<h3 id=\"403-forbidden\">403 Forbidden</h3>\n<p>The client may have authorized, but they are still not allowed to make the request. (Maybe they don&#39;t have the right access rights).</p>\n<h3 id=\"404-not-found\">404 Not Found</h3>\n<p>No description required. :)</p>\n<h3 id=\"415-unsupported-media-type\">415 Unsupported Media Type</h3>\n<p>The client is speaking in a language that the server cannot understand</p>\n<h2 id=\"5xx-codes-server-error\">5XX Codes - Server error</h2>\n<p>The 4XX codes are when the client screws up when sending the request. The 5XX codes are when the server screws up when sending the response. It&#39;s basically the server saying, Ok, I got your request, and it looked like a valid one, but something went wrong when I tried to process it.</p>\n<h3 id=\"500-internal-server-error\">500 Internal Server Error</h3>\n<p>This is a generic error code. The server gets a request. The resource exists (or you&#39;d send a 404 instead) but something went wrong when processing the request. In such cases, the standard practice is to send the error code 500, along with error details in the body of the request.</p>\n<p>There are a bunch of other codes, but these are the important ones to remember. We&#39;ll look at more when we start implementing some of these APIs. But let me remind you again. These error codes are for you, as a web service developer to use. The clients know what it means when they see one of these error codes. So, it&#39;s up to you to send the right error codes when these events happen. For example, let&#39;s say you get a runtime exception when processing a request. You need to send back error code 500. Because it means server error. And the client will then know what&#39;s happened.</p>\n<h2 id=\"scenarios\">Scenarios</h2>\n<p>Let&#39;s look at the same CRUD use cases we saw in the previous tutorial, and identify what the status codes should be for the message resource</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th style=\"text-align:center\">URI</th>\n<th>Method</th>\n<th>Success / Failure</th>\n<th>Status code</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get message</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}</code></td>\n<td>GET</td>\n<td>Success</td>\n<td>200</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Delete message</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}</code></td>\n<td>DELETE</td>\n<td>Success</td>\n<td>200 or 204 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Edit message</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}</code></td>\n<td>PUT</td>\n<td>Success</td>\n<td>200 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Create message</td>\n<td style=\"text-align:center\"><code>/messages</code></td>\n<td>POST</td>\n<td>Success</td>\n<td>201 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n</tbody>\n</table>\n<p>Hope this gives you a better idea of the status codes to be returned. Responses for other resources would mostly follow the same pattern. Again, this is just a small subset of the HTTP status codes, and we&#39;ll look at more when we start implementing APIs.</p>\n<p>In this tutorial, we learnt about:</p>\n<ol>\n<li>Resource representations</li>\n<li>Message headers in HTTP and</li>\n<li>HTTP status codes</li>\n</ol>\n","type":"video","durationText":"16 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we'll learn about an important concept relating to REST APIs: HATEOAS\n","permalinkName":"HATEOAS","title":"HATEOAS","unitSlNo":"1.12","youtube":"NK3HNEwDXUk","duration":854,"slNo":12,"prev":"/courses/javaee_jaxrs/lessons/Rest-Response","next":"/courses/javaee_jaxrs/lessons/The-Richardson-Maturity-Model","content":"<p>That&#39;s not a typo. This is actually an acronym. HATEOAS. In the running for the worst acronym ever. It stands for Hypermedia as the Engine of Application State. I know. Worst acronym ever, huh? But bear with me, and you&#39;ll soon understand what that means.</p>\n<h2 id=\"hyperlinking\">Hyperlinking</h2>\n<p>Maybe you remember, I mentioned in the first video of this series that there&#39;s no service definition specification for REST APIs. There&#39;s no formal document that really documents the API. Most REST APIs have &quot;help&quot; pages that explain what the API URIs are and what operations are supported. I also mentioned in the first video that the best RESTful APIs don&#39;t even need any documentation. I&#39;ll now explain what I mean by that.</p>\n<p>So, we visit websites online all the time. When was the last time you looked up any documentation to use a website? Well, never, I hope. You don&#39;t need documentation to use web sites. You go to the home page, and you&#39;ll find links to other pages. You click on one such link, and you&#39;ll get that page, with more links. You don&#39;t need to read a document to know where to go. You just remember the website home address, and any other links you need to navigate will be provided to you in the response.</p>\n<p>This is basically the advantage of using HTTP. Remember that HTTP is HyperText Transfer Protocol. We&#39;ve discussed that hypertext is text that has links to other text. These links, which are called hyperlinks, are what&#39;s really handy to navigate your way through any site. Let&#39;s think about the response we return in our REST API. What if we implement the same concept there too? Let&#39;s say you receive a GET request from a client for a message ID. We return the message information in JSON or XML, yes. But what you could also do is send links to comment resource URIs. And likes and shares resource URIs. It&#39;s the server saying &quot;Hey client, I know you asked for message ID 20. Here&#39;s the contents of message #20. I&#39;m also throwing in collection resource URIs for comments, shares and likes. If you want to get a list of all the comments for message ID 20, this is the URI to use. Oh, and here&#39;s the profile resource URI for the author of the message, if you want to get the profile information of the author of this message&quot;. </p>\n<p>So, the web service is being super-helpful to the client by providing all these links in the response. Similar to hyperlinks in web sites. Whether the client wants to use it or not doesn&#39;t matter. But if they want it, it&#39;s there. And just like that, you&#39;ve eliminated the need for documentation for all these APIs. The client developer just picks up the value of the right URIs from a previous response and makes subsequent calls to those URIs. </p>\n<p>If you do this, you don&#39;t let the client programmer have to know and hard-code the URIs in order to interact with the resources and the application state. You basically let the hypertext you send in the response drive the client&#39;s interaction with the application state. So, you could say that hypertext, or hypermedia as it is sometimes called, is being the driver or engine of application state. Hypermedia as the Engine of Application State. HATEOAS. Whew. Does that make sense now? It&#39;s still a bad choice for a name. But it should at least make some sense now.</p>\n<h2 id=\"a-scenario\">A Scenario</h2>\n<p>Let&#39;s walk through a scenario so that this concept becomes clearer. Let&#39;s start with the <code>/messages</code> collection URI. Accessing <code>/messages</code> should give you a list of messages in the system. Let&#39;s say a message representation has the following fields:</p>\n<ol>\n<li>Message ID</li>\n<li>Message Content</li>\n<li>Message Author</li>\n<li>Posted Date</li>\n</ol>\n<p>Four simple properties. A JSON representation for a sample message would look something like this:</p>\n<pre><code>{\n  &quot;id&quot;: &quot;01&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;\n}\n</code></pre><p>Now when you access the <code>/messages</code> collection URI, you&#39;d basically get a collection of such message resources. To keep it simple, let&#39;s say there are just 3 messages in the system. Accessing <code>/messages</code> would give something similar to this:</p>\n<pre><code>[\n  {\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;\n  },\n  {\n  &quot;id&quot;: &quot;2&quot;,\n  &quot;content&quot;: &quot;Yo!&quot;,\n  &quot;author&quot;: &quot;sid&quot;,\n  &quot;postedDate&quot;: &quot;04-01-2014&quot;\n  },\n  {\n  &quot;id&quot;: &quot;3&quot;,\n  &quot;content&quot;: &quot;What&#39;s up?&quot;,\n  &quot;author&quot;: &quot;jane&quot;,\n  &quot;postedDate&quot;: &quot;04-02-2014&quot;\n  }\n]\n</code></pre><p>Now that the client has the list of messages, let&#39;s say they want the details of the first message - message ID 1. We&#39;ve already designed the resource URI for message to be <code>/messages/{messageId}</code>. So, to get the URI, they&#39;ll have to take the value of the ID field of the message they are interested in, and append it to the string <code>/messages/</code> and there they have the resource URI. But this means that the client will have to know this beforehand. They need to know that they need to pick up the ID property from the response, and they need to know what to append it to. Now, here&#39;s a question. As a API service implementer, why not send that to the client yourself? Since we are sending the message resource details anyway, why not just construct the URI fully and send it to the client? </p>\n<p>Consider a sample response for a single message like this:</p>\n<pre><code>{\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;,\n  &quot;href&quot;: &quot;/messages/1&quot;\n}\n</code></pre><p>If this were to be the kind of response for every message in <code>/messages</code>, then the client wouldn&#39;t really have to do any URI construction. The resource URI is one of the properties of the resource. If you were to design your API so that every resource has the instance resource URI to itself, it makes it really convenient for the client to use it.</p>\n<p>Notice that the name of the link property is <code>href</code>. That must be familiar. That&#39;s exactly how you specify links in HTML. <code>href</code> is a property of the <code>&lt;a&gt;</code> tag. It serves a similar purpose here.</p>\n<h2 id=\"link-relations\">Link relations</h2>\n<p>We are on our way to implementing some HATEOAS concepts. We are not fully there yet. There are still some more things you&#39;ll need to learn. Let&#39;s look at the concept of links, and how you can apply them to the resources in the Messenger API. We&#39;ve looked at adding the resource URI to every resource. So, a profile resource, or a comment resource, well, pretty much every resource could have a <code>href</code> attribute that has the value of the instance resource URI. Bu that&#39;s not the only link you can provide. For instance, a message resource could also have links to get all the comments for that message. And all the likes and shares for that message. You could even have links for the client to post a new comment to that message. Keep extending this, and it gets a bit messy.</p>\n<pre><code>{\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;,\n  &quot;href&quot;: &quot;/messages/1&quot;,\n  &quot;comments-href&quot;: &quot;/messages/1/comments&quot;,\n  &quot;likes-href&quot;: &quot;/messages/1/likes&quot;,\n   &quot;shares-href&quot;: &quot;/messages/1/shares&quot;,\n   &quot;profile-href&quot;: &quot;/profiles/koushik&quot;,\n   &quot;comment-post-href&quot;: &quot;/messages/1/comments&quot;\n}\n</code></pre><p>If you do this, the client doesn&#39;t need to remember the URIs, yes, but they now have to remember the property names for these URIs and you basically have then same problem. There needs to be a better way to manage these links. And there is! You can use the <code>rel</code> attribute. </p>\n<p>If you&#39;ve used the anchor tags when writing HTML, you might have encountered this <code>rel</code> attribute before. It&#39;s basically an attribute that you can add to any link to specify the relationship between the current document and  the linked document. </p>\n<p>The most common example of <code>rel</code> is in stylesheet links. You&#39;d have seen stylesheet links in HTML head tags like this:</p>\n<p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/some.css&quot;/&gt;</code></p>\n<p>Here <code>href</code> provides the actual URL being linked, and the <code>rel</code> attribute describes the relation of that link to the main document. Here the relation is that the link is a stylesheet of the main document.</p>\n<p>We can use the <code>rel</code> attribute to add extra information in the links in our REST response. Here&#39;s the original href response modified with the <code>rel</code> attribute addition:</p>\n<pre><code>{\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;,\n   &quot;links&quot; : [\n                {  \n                    &quot;href&quot;: &quot;/messages/1&quot;,\n                    &quot;rel&quot;: &quot;self&quot;\n                }\n            ]\n}\n</code></pre><p>What&#39;s different here is that we&#39;ve introduced this new property called <code>links</code> which is an array. This is going to contain all the links that you&#39;d want to embed in the response. However, you add the <code>rel</code> attribute to make it clear what the link points to. Notice the <code>rel</code> value <code>self</code> which indicates that the link in the resource points to itself.</p>\n<p>This could be extended by adding new links and assigning the appropriate rel values for each:</p>\n<pre><code>{\n  &quot;id&quot;: &quot;1&quot;,\n  &quot;content&quot;: &quot;Hello World!&quot;,\n  &quot;author&quot;: &quot;koushik&quot;,\n  &quot;postedDate&quot;: &quot;03-01-2014&quot;,\n   &quot;links&quot; : [\n                {  \n                    &quot;href&quot;: &quot;/messages/1&quot;,\n                    &quot;rel&quot;: &quot;self&quot;\n                },\n                {  \n                    &quot;href&quot;: &quot;/messages/1/comments&quot;,\n                    &quot;rel&quot;: &quot;comments&quot;\n                },\n                {  \n                    &quot;href&quot;: &quot;/messages/1/likes&quot;,\n                    &quot;rel&quot;: &quot;likes&quot;\n                },\n                {  \n                    &quot;href&quot;: &quot;/messages/1/shares&quot;,\n                    &quot;rel&quot;: &quot;shares&quot;\n                },\n                {  \n                    &quot;href&quot;: &quot;/profiles/koushik&quot;,\n                    &quot;rel&quot;: &quot;author&quot;\n                }\n            ]\n}\n</code></pre><p>Now the client doesn&#39;t need to remember the link property values. They just have to find the link with the right <code>rel</code> value for the resource they want and then look up the <code>href</code> value from that link.</p>\n<p>A couple of things to note here. While the concept of having the URIs in the response to achieve HATEOAS is something that&#39;s well understood and mostly agreed upon by all, the <em>way</em> to do this could vary differently among implementations. The format of JSON that I&#39;ve outlined here is just one of the multitude of ways you could structure links. Again, there&#39;s no right or wrong. You can choose to tweak how you want to present the links in the JSON response of your API depending on your preference. Secondly, the <code>rel</code> attribute is a part of the HTTP specification, so there are only certain standard values that are allowed for it. <a href=\"http://www.iana.org/assignments/link-relations/link-relations.xml\">This link</a> lists the available values. And obviously, the <code>rel</code> values here like &quot;comments&quot; and &quot;likes&quot; are not valid. But we&#39;ll still use it. Like I mentioned before, the idea is to have an API that&#39;s easy for the clients to use, and easy for you to maintain. You don&#39;t want to focus too much on getting things right and going by the book. At least, not at the cost of complicating the API too much.</p>\n<p>In summary, HATEOAS is a way to provide links to resources in the API response, so that the client doesn&#39;t have to deal with URI construction and business flow. They make a request, and the next steps, along with the URIs are handed to them in the response. When you write APIs, you can choose to add URIs in the response using the <code>href</code> attribute. You can also provide more information about the relationship of the linked resource using the <code>rel</code> attribute.</p>\n","type":"video","durationText":"14 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we'll learn about the Richardson Maturity Model, a way for REST APIs to be classified, and the \"RESTfulness\" of an API determined.","permalinkName":"The-Richardson-Maturity-Model","title":"The Richardson Maturity Model","unitSlNo":"1.13","youtube":"qHbTE3qvUsQ","duration":506,"slNo":13,"prev":"/courses/javaee_jaxrs/lessons/HATEOAS","next":"/courses/javaee_jaxrs/lessons/What-Is-JAXRS","content":"<p>This is the final tutorial in section 1 API design. We&#39;ve looked at different factors when building the RESTful API for the Messenger application. In this tutorial, we&#39;ll wrap up and take an overall look at how far we&#39;ve come and what that means.</p>\n<p>Below is the API documentation summary of what we have so far. I hope the choices and the design approach for this API is clear to you now. If you are unsure of why any part of the API is a particular way, I encourage you to revisit the relevant tutorial. </p>\n<h2 id=\"messages\">Messages</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th style=\"text-align:center\">URI</th>\n<th>Method</th>\n<th>Success / Failure</th>\n<th>Status code</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get message</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}</code></td>\n<td>GET</td>\n<td>Success</td>\n<td>200</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Delete message</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}</code></td>\n<td>DELETE</td>\n<td>Success</td>\n<td>200 or 204 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Edit message</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}</code></td>\n<td>PUT</td>\n<td>Success</td>\n<td>200 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Create message</td>\n<td style=\"text-align:center\"><code>/messages</code></td>\n<td>POST</td>\n<td>Success</td>\n<td>201 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"profiles\">Profiles</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th style=\"text-align:center\">URI</th>\n<th>Method</th>\n<th>Success / Failure</th>\n<th>Status code</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get profile</td>\n<td style=\"text-align:center\"><code>/profiles/{profileName}</code></td>\n<td>GET</td>\n<td>Success</td>\n<td>200</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Delete profile</td>\n<td style=\"text-align:center\"><code>/profiles/{profileName}</code></td>\n<td>DELETE</td>\n<td>Success</td>\n<td>200 or 204 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Edit profile</td>\n<td style=\"text-align:center\"><code>/profiles/{profileName}</code></td>\n<td>PUT</td>\n<td>Success</td>\n<td>200 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Create profile</td>\n<td style=\"text-align:center\"><code>/profiles</code></td>\n<td>POST</td>\n<td>Success</td>\n<td>201 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"comments-and-similarly-likes-and-shares-\">Comments (and similarly Likes and Shares)</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th style=\"text-align:center\">URI</th>\n<th>Method</th>\n<th>Success / Failure</th>\n<th>Status code</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get comment</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}/comments/{commentId}</code></td>\n<td>GET</td>\n<td>Success</td>\n<td>200</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Delete comment</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}/comments/{commentId}</code></td>\n<td>DELETE</td>\n<td>Success</td>\n<td>200 or 204 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Edit comment</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}/comments/{commentId}</code></td>\n<td>PUT</td>\n<td>Success</td>\n<td>200 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Create comment</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}/comments</code></td>\n<td>POST</td>\n<td>Success</td>\n<td>201 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n</tbody>\n</table>\n<p>Now that we have designed the API this way, let&#39;s look at what this means. Are we in a position to say this API is &quot;<em>fully RESTful</em>&quot;? Remember, in the first tutorial, I mentioned that this isn&#39;t a yes or no question, and that there is a spectrum of anywhere from &quot;<em>not fully RESTful</em>&quot; to &quot;<em>almost RESTful</em>&quot; to &quot;<em>not RESTful at all</em>&quot;. These terms are hard to work with. How do you <em>know</em> how RESTful an API is? Well, there is one way to know, and that&#39;s using a model developed by Leonard Richardson. It&#39;s called the Richardson Maturity Model, and it breaks down all the concepts we&#39;ve discussed into 3 levels. Every REST API belongs to one of these 3 levels. The model also defines a Level 0 which is <em>not a RESTful API</em>. It is not necessary that every API score highly as per this model. But it helps to understand this model when designing any RESTful API so that you at least know where you stand. And try to make it better if possible.</p>\n<p>Let&#39;s start with Level 0. I hope you are familiar with some of the basics of a SOAP web service. The way a SOAP web service generally works is that there is a URL called the endpoint where the service is exposed. One URL. That URL receives all requests from the client. If you were to write the Messenger API as a SOAP web service, you&#39;d probably have one URI at <servername>/messenger. This URL receives <em>all</em> requests. How does it know what to do? How does the client tell it to do different stuff, like look up messages or delete a comment? Well, that happens in the message that&#39;s sent to this common URL. The message contains both the operation that needs to be performed, and the data that&#39;s needed for that operation. For example, the XML below could create a new message:</p>\n<pre><code>&lt;create-message&gt;\n    &lt;message-content&gt;Hello World!&lt;/message-content&gt;\n    &lt;message-author&gt;koushik&lt;/message-author&gt;\n&lt;/create-message&gt;\n</code></pre><p>And a delete comment request (sent to the same URL) could look like this. </p>\n<pre><code>&lt;delete-comment&gt;\n    &lt;message-id&gt;30&lt;/message-id&gt;\n    &lt;comment-id&gt;2&lt;/comment-id&gt;\n&lt;/delete-comment&gt;\n</code></pre><p>Notice that the operation that needs to be performed is a part of the request that&#39;s sent. This is how the same URL can be used for different operations. In fact, the same HTTP method can be used for each operation, because, all the details are in the request body. In fact, that&#39;s what SOAP does. The requests are always POST, with the POST body containing all the information.</p>\n<p>This is Level 0 in the Richardson Maturity Model. This is often called the <strong>The swamp of POX</strong>. This refers to the common use of <em>Plain Old XML</em> (or POX) to define everything that an operation needs. No HTTP concepts are leveraged for communicating information between the server and client.</p>\n<p>This design approach is obviously not something we want to do in this course. If you were to refine this model to introduce the concept of resource URIs, you will reach level 1 in the RMM. This is the starting level for RESTful APIs. The earlier level isn&#39;t even considered REST. We designed resource URIs for messages (<code>/messages</code>), profiles (<code>/profiles</code>) and so on. If you did just this, and nothing else, you stand at level 1. Now you have message requests going to one URI and all comments requests going to another URI. There would still be information about the operation in the requests, because the message URI needs to handle adding deleting or updating messages. </p>\n<p>If you take the next step and use different HTTP methods for these different operations, then you&#39;ve reached Level 2 in RMM. An API on Level 2 uses standard HTTP methods like GET, POST, PUT and DELETE to do different operations, on the resource URI. The URI specifies what resource is operated upon, and the HTTP method specifies what the operation is. There also needs to be better use of HTTP status codes, and the right use of idempotent and non-idempotent methods for an API to be at Level 2. </p>\n<p>Finally, Level 3 is when you implement HATEOAS. That is, the responses have links that control the application state for the client. The client doesn&#39;t need to be aware of the different API URIs. All the URIs that the client would need is a part of the response that the server sends. If an API implements this, it is said to be at Level 3 of RMM, and is considered fully RESTful.</p>\n<p>And there you go. Now you can look at any REST API design and easily identify which level in RMM it belongs to. Again, this is not supposed to be a strict rule. I encourage you to use this model as a guideline when designing your REST APIs, as a tool for learning and understanding, rather than a scorecard to measure with. You may not choose to make every API achieve Level 3 of RMM, but it helps to understand what the theoretical <em>ideal</em> is.</p>\n<p>In the next section, we&#39;ll start looking at JAX-RS and start implementing this API. There&#39;s a lot to REST API design, and these tutorials have only scratched the surface. So, I do encourage you to explore more about REST APIs, and treat these tutorials as a starting point, rather than as complete learning.</p>\n","type":"video","durationText":"8 minutes"}],"firstLesson":"/courses/javaee_jaxrs/lessons/Introduction"},"2":{"courseCode":"javaee_jaxrs","unitDescription":"In this unit, we learn about writing REST APIs in Java with JAX-RS. We will build the Messenger API with JAX-RS and Jersey.","unitName":"Implementation with JAX-RS","unitNumber":2,"lessons":[{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we understand what JAX-RS is and how it relates to Jersey, the implementation library.","permalinkName":"What-Is-JAXRS","title":"What Is JAXRS","unitSlNo":"2.1","youtube":"BuYivu9ZjDw","duration":452,"slNo":1,"prev":"/courses/javaee_jaxrs/lessons/The-Richardson-Maturity-Model","next":"/courses/javaee_jaxrs/lessons/Setting-Up","type":"video","durationText":"7 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"We will now setup a new project in our development environment to start writing a REST API application.","permalinkName":"Setting-Up","title":"Setting Up","unitSlNo":"2.2","youtube":"skltzZH7i4w","duration":645,"slNo":2,"prev":"/courses/javaee_jaxrs/lessons/What-Is-JAXRS","next":"/courses/javaee_jaxrs/lessons/Understanding-The-Application-Structure","content":"<h2 id=\"prerequisites\">Prerequisites</h2>\n<ol>\n<li>Latest Java EE version of Eclipse installed (Make sure you install the Java EE version, not the Java version)</li>\n</ol>\n<h2 id=\"steps\">Steps</h2>\n<ol>\n<li>Open Eclipse and Choose New &gt; Project &gt; Maven Project</li>\n<li><p>Choose &quot;Add Archetype&quot; and enter the following details:</p>\n<p> <strong>Archetype Group ID</strong>: <code>org.glassfish.jersey.archetypes</code></p>\n<p> <strong>Archetype Artifact ID</strong>: <code>jersey-quickstart-webapp</code></p>\n<p> <strong>Archetype Version</strong>: <code>2.16</code></p>\n</li>\n<li><p>Choose the newly entered archetype from the Archetype selection screen</p>\n</li>\n<li>Enter your project details - Group ID, Artifact ID and version.</li>\n<li>Setup Tomcat in your Eclipse workspace</li>\n<li>Right click on the project and choose Run As &gt; Run on server. </li>\n</ol>\n<h2 id=\"maven\">Maven</h2>\n<p>Take the <a href=\"http://javabrains.koushik.org/courses/maven_intro\">Introduction to Maven</a> course here: <a href=\"http://javabrains.koushik.org/courses/maven_intro\">http://javabrains.koushik.org/courses/maven_intro</a> </p>\n","type":"video","durationText":"10 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Let's now look under the hood and understand how the REST API application works. We'll understand some of the components that handle the API requests and how they fit together.","permalinkName":"Understanding-The-Application-Structure","title":"Understanding The Application Structure","unitSlNo":"2.3","youtube":"rKSnB3Bl12w","duration":475,"slNo":3,"prev":"/courses/javaee_jaxrs/lessons/Setting-Up","next":"/courses/javaee_jaxrs/lessons/Creating-A-Resource","type":"video","durationText":"7 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we'll create our first JAX-RS resource that handles a GET request to an API URL.","permalinkName":"Creating-A-Resource","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/43f5a224b7de3099fbd96deee7c0ddb3706059f2.zip","title":"Creating A Resource","unitSlNo":"2.4","youtube":"2QD1sOG8pyU","duration":871,"slNo":4,"prev":"/courses/javaee_jaxrs/lessons/Understanding-The-Application-Structure","next":"/courses/javaee_jaxrs/lessons/Returning-Xml-Response","type":"video","durationText":"14 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Let's return some data in XML format from the resource. We'll update the MessageResource to return a list of Messages in XML.","permalinkName":"Returning-Xml-Response","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/22403d7b65282e3f970201118470baa2afa10eaf.zip","title":"Returning Xml Response","unitSlNo":"2.5","youtube":"BaZdlJSts5A","duration":653,"slNo":5,"prev":"/courses/javaee_jaxrs/lessons/Creating-A-Resource","next":"/courses/javaee_jaxrs/lessons/Installing-A-Rest-Api-Client","type":"video","durationText":"10 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Now I'll introduce you to a REST API client that will be useful for the rest of the course, for making REST API calls. The example client I demonstrate, called Postman, is a Chrome add-on.","permalinkName":"Installing-A-Rest-Api-Client","title":"Installing A Rest Api Client","unitSlNo":"2.6","youtube":"vbP1ZCDfIfw","duration":385,"slNo":6,"prev":"/courses/javaee_jaxrs/lessons/Returning-Xml-Response","next":"/courses/javaee_jaxrs/lessons/Building-Service-Stubs","type":"video","durationText":"6 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we'll build and stub business and data services that we can call from the Message resource class.","permalinkName":"Building-Service-Stubs","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/3130c8a71502e6601d644317a7dca2caa5e44786.zip","title":"Building Service Stubs","unitSlNo":"2.7","youtube":"UXdoBGLDnRg","duration":666,"slNo":7,"prev":"/courses/javaee_jaxrs/lessons/Installing-A-Rest-Api-Client","next":"/courses/javaee_jaxrs/lessons/Accessing-Path-Params","type":"video","durationText":"11 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, you'll learn how to access and map to URL with path parameters, using the @PathParam annotation.","permalinkName":"Accessing-Path-Params","title":"Accessing Path Params","unitSlNo":"2.8","youtube":"U4tOw0LxQW4","duration":808,"slNo":8,"prev":"/courses/javaee_jaxrs/lessons/Building-Service-Stubs","next":"/courses/javaee_jaxrs/lessons/Returning-JSON-Response","type":"video","durationText":"13 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"We'll now switch the response format of the APIs from XML to JSON.","permalinkName":"Returning-JSON-Response","title":"Returning JSON Response","unitSlNo":"2.9","youtube":"5KLFUwcIKkw","sourceCode":"https://github.com/koushikkothagal/messenger/archive/c9d73a2a063ecf5bf2d59008b99c723e1dcb09c9.zip","duration":305,"slNo":9,"prev":"/courses/javaee_jaxrs/lessons/Accessing-Path-Params","next":"/courses/javaee_jaxrs/lessons/Implementing-POST-Method","type":"video","durationText":"5 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we'll implement the POST method API to create new instances of Message resource.","permalinkName":"Implementing-POST-Method","sourceCode":"https://github.com/koushikkothagal/messenger/archive/d946c045190741c85ceaf3714e97d3ed84e1bb89.zip","title":"Implementing POST Method","unitSlNo":"2.10","youtube":"6HWUrp6buqQ","duration":490,"slNo":10,"prev":"/courses/javaee_jaxrs/lessons/Returning-JSON-Response","next":"/courses/javaee_jaxrs/lessons/Implementing-Update-And-Delete","type":"video","durationText":"8 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"We'll now implement update and delete APIs with the PUT and DELETE methods respectively.","permalinkName":"Implementing-Update-And-Delete","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/d9397f15b60d8dcf0b79635ff3a69b1dcb7a2a2f.zip","title":"Implementing Update And Delete","unitSlNo":"2.11","youtube":"HePAArH5BrU","duration":559,"slNo":11,"prev":"/courses/javaee_jaxrs/lessons/Implementing-POST-Method","next":"/courses/javaee_jaxrs/lessons/Implementing-ProfileResource","type":"video","durationText":"9 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Now, we'll implement another resource, the ProfileResource class.","permalinkName":"Implementing-ProfileResource","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/16deac4112683089806da75eabc74ae6218b6882.zip","title":"Implementing ProfileResource","unitSlNo":"2.12","youtube":"Ik7jv3d-1qY","duration":832,"slNo":12,"prev":"/courses/javaee_jaxrs/lessons/Implementing-Update-And-Delete","next":"/courses/javaee_jaxrs/lessons/Pagination-And-Filtering","type":"video","durationText":"13 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we'll learn how to implement pagination and filtering features in REST APIs.","permalinkName":"Pagination-And-Filtering","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/4ecca03a0ea1c5ebe96fdb8cdd1875b59ea12970.zip","title":"Pagination And Filtering","unitSlNo":"2.13","youtube":"WC6wy3Kg5pk","duration":719,"slNo":13,"prev":"/courses/javaee_jaxrs/lessons/Implementing-ProfileResource","next":"/courses/javaee_jaxrs/lessons/The-Param-Annotations","type":"video","durationText":"11 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, you'll learn about a few more Param annotations that inject request values into resource methods.","permalinkName":"The-Param-Annotations","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/61673b6807baf891d9b414641cce7378259ee88c.zip","title":"The Param Annotations","unitSlNo":"2.14","youtube":"Mqpgca6654Q","duration":545,"slNo":14,"prev":"/courses/javaee_jaxrs/lessons/Pagination-And-Filtering","next":"/courses/javaee_jaxrs/lessons/Using-Context-And-BeanParam-Annotations","type":"video","durationText":"9 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In this tutorial, we'll cover a few more ways to have request information injected into resource methods. We'll look at Context and BeanParam annotations.","permalinkName":"Using-Context-And-BeanParam-Annotations","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/8169659fe20bb70d06ff9304a1a4409507c12a60.zip","title":"Using Context And BeanParam Annotations","unitSlNo":"2.15","youtube":"4nZUT1oBI1g","duration":647,"slNo":15,"prev":"/courses/javaee_jaxrs/lessons/The-Param-Annotations","next":"/courses/javaee_jaxrs/lessons/Implementing-Subresources","type":"video","durationText":"10 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"We'll now implement nested resources using the \"sub-resources\" feature in JAX-RS. ","permalinkName":"Implementing-Subresources","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/cdd7486aef1382bfd1f7bf1c7e644431b337ce08.zip","title":"Implementing Subresources","unitSlNo":"2.16","youtube":"O4dAxOCYAUg","duration":980,"slNo":16,"prev":"/courses/javaee_jaxrs/lessons/Using-Context-And-BeanParam-Annotations","next":"/courses/javaee_jaxrs/lessons/Sending-Status-Codes-and-Location-Headers","type":"video","durationText":"16 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Learn how to send status codes and location headers from REST APIs. We'll update the create API to send the 201 status code and the Location header.","permalinkName":"Sending-Status-Codes-and-Location-Headers","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/4d90001ed0ac38e676685eec699f82263bea1b97.zip","title":"Sending Status Codes and Location Headers","unitSlNo":"2.17","youtube":"HEabElNrfbo","duration":1070,"slNo":17,"prev":"/courses/javaee_jaxrs/lessons/Implementing-Subresources","next":"/courses/javaee_jaxrs/lessons/Handling-Exceptions","type":"video","durationText":"17 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Learn how to handle exceptions in a REST API application using Jersey's ExceptionMapper.","permalinkName":"Handling-Exceptions","title":"Handling Exceptions","unitSlNo":"2.18","youtube":"9oeJc_VkZxo","duration":1075,"slNo":18,"prev":"/courses/javaee_jaxrs/lessons/Sending-Status-Codes-and-Location-Headers","next":"/courses/javaee_jaxrs/lessons/Using-WebApplicationException","type":"video","durationText":"17 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"Here's another way to handle exception scenarios in JAX-RS, using WebApplicationException.","permalinkName":"Using-WebApplicationException","title":"Using WebApplicationException","unitSlNo":"2.19","youtube":"Vdk_tUhcJZM","duration":640,"slNo":19,"prev":"/courses/javaee_jaxrs/lessons/Handling-Exceptions","next":"/courses/javaee_jaxrs/lessons/HATEOAS-Part-1","type":"video","durationText":"10 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In Part 1 of this 2-part tutorial, we'll implement HATEOAS links in the Message response for the \"self\" rel attribute.","permalinkName":"HATEOAS-Part-1","title":"HATEOAS Part 1","unitSlNo":"2.20","youtube":"Mp6LpIg7h84","duration":654,"slNo":20,"prev":"/courses/javaee_jaxrs/lessons/Using-WebApplicationException","next":"/courses/javaee_jaxrs/lessons/HATEOAS-Part-2","type":"video","durationText":"10 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"In Part 2 of this 2-part tutorial, we'll implement HATEOAS links in the Message response for the \"profile\" and \"comment\" rel attributes.","permalinkName":"HATEOAS-Part-2","sections":null,"sourceCode":"https://github.com/koushikkothagal/messenger/archive/a016c1af1b9a195c6518c5fce60282be215efc73.zip","title":"HATEOAS Part 2","unitSlNo":"2.21","youtube":"dtO5NQ8K5Wo","duration":573,"slNo":21,"prev":"/courses/javaee_jaxrs/lessons/HATEOAS-Part-1","next":"/courses/javaee_jaxrs/lessons/Content-Negotiation","type":"video","durationText":"9 minutes"},{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"I'll now introduce you to an interesting concept called Content Negotiation, and how different content types can be handled in JAX-RS.","permalinkName":"Content-Negotiation","title":"Content Negotiation","unitSlNo":"2.22","youtube":"vP9HU1o3zsE","duration":784,"slNo":22,"prev":"/courses/javaee_jaxrs/lessons/HATEOAS-Part-2","type":"video","durationText":"13 minutes"}],"firstLesson":"/courses/javaee_jaxrs/lessons/What-Is-JAXRS"}},"durationText":"5 minutes"}